<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <title>超简单聊天</title>
    <style>
      * {
        box-sizing: border-box; /* 全局设置，避免元素超出 */
      }

      body {
        font-family: Arial, sans-serif;
        padding: 0;
        margin: 0;
        background: #f5f5f5;
        height: 100vh;
        overflow: hidden;
      }
      .container {
        background: white;
        padding: 20px;
        height: 100vh;
        display: flex;
        flex-direction: column;
        border-radius: 0;
        box-shadow: none;
      }

      /* 连接阶段的容器样式 */
      .container.connecting-phase {
        max-width: 800px;
        margin: 0 auto;
        height: auto;
        min-height: 100vh;
        border-radius: 0;
        padding: 20px;
      }

      /* 已连接状态的容器样式 */
      .container.connected-phase {
        padding: 0;
        max-width: none;
        width: 100%;
      }
      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
      }
      .step {
        background: #f8f9fa;
        padding: 20px;
        margin: 20px 0;
        border-radius: 10px;
        border-left: 5px solid #007bff;
      }
      button {
        background: #007bff;
        color: white;
        border: none;
        padding: 15px 25px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        margin: 5px;
      }
      button:hover {
        background: #0056b3;
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      textarea {
        width: 100%;
        height: 60px;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 5px;
        margin: 10px 0;
        font-family: monospace;
        font-size: 12px;
        resize: none;
      }
      #messages {
        background: #ffffff;
        border: 2px solid #e0e0e0;
        border-radius: 15px;
        height: 300px;
        overflow-y: auto;
        padding: 20px;
        margin: 20px 0;
        box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05);
        flex: 1;
      }

      /* 连接状态下的消息区域样式 */
      .connected-phase #messages {
        height: auto;
        flex: 1;
        margin: 0;
        border: none;
        border-radius: 0;
        background: #f8f9fa;
        box-shadow: none;
        padding: 15px;
      }
      .message {
        margin: 12px 0;
        padding: 12px 16px;
        border-radius: 18px;
        max-width: 75%;
        word-wrap: break-word;
        position: relative;
        animation: fadeIn 0.3s ease-out;
      }
      .me {
        background: linear-gradient(135deg, #007bff, #0056b3);
        color: white;
        margin-left: auto;
        text-align: right;
        box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
      }
      .me::after {
        content: "";
        position: absolute;
        right: -8px;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border: 8px solid transparent;
        border-left-color: #007bff;
      }
      .them {
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        color: #333;
        border: 1px solid #dee2e6;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .them::after {
        content: "";
        position: absolute;
        left: -8px;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border: 8px solid transparent;
        border-right-color: #f8f9fa;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* 聊天框为空时的提示 */
      #messages:empty::before {
        content: "💬 聊天消息会在这里显示...";
        color: #999;
        font-style: italic;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        text-align: center;
      }
      #messageInput {
        width: 70%;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 5px;
        margin-right: 10px;
      }
      .status {
        text-align: center;
        padding: 10px;
        border-radius: 5px;
        margin: 15px 0;
        font-weight: bold;
      }
      .flex {
        display: flex;
        align-items: center;
      }

      /* 优化连接区域布局 */
      .connection-area {
        display: flex;
        gap: 20px;
        margin: 20px 0;
      }

      .connection-box {
        flex: 1;
        border: 2px dashed;
        padding: 20px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.8);
      }

      .connection-box h4 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 16px;
      }

      .connection-box button {
        width: 100%;
        margin-bottom: 12px;
        padding: 12px;
        font-size: 14px;
      }

      .connection-box textarea {
        width: 100%;
        margin-top: 10px;
        padding: 12px;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-family: monospace;
        font-size: 11px;
        resize: none;
        min-height: 80px;
      }

      /* 响应式设计 */
      @media (max-width: 768px) {
        body {
          padding: 10px;
        }

        .container {
          padding: 20px;
        }

        h1 {
          font-size: 24px;
          margin-bottom: 20px;
        }

        .connection-area {
          flex-direction: column;
          gap: 15px;
        }

        .connection-box {
          padding: 15px;
        }

        .connection-box h4 {
          font-size: 14px;
        }

        .connection-box button {
          padding: 10px;
          font-size: 13px;
        }

        .connection-box textarea {
          min-height: 60px;
          font-size: 10px;
        }

        .connection-progress {
          padding: 15px;
          margin: 15px 0;
        }

        .connection-progress h4 {
          font-size: 16px;
        }

        .progress-step {
          font-size: 13px;
          margin: 8px 0;
          padding: 6px 0;
        }

        .simplified-header {
          padding: 12px 15px;
          margin-bottom: 15px;
        }

        .simplified-header h2 {
          font-size: 16px;
        }

        .simplified-header .status-info {
          font-size: 11px;
        }

        #messageInput {
          font-size: 16px; /* 防止iOS放大 */
          padding: 10px !important;
        }

        #send {
          padding: 10px 15px !important;
          font-size: 13px !important;
          min-width: 60px !important;
        }

        #messages {
          height: 250px;
          padding: 15px;
        }

        .connected-phase #messages {
          padding: 10px;
        }

        .input-area {
          padding: 10px !important;
        }

        .input-row {
          gap: 8px !important;
        }

        #imageBtn {
          min-width: 40px !important;
          height: 40px !important;
          padding: 8px !important;
          font-size: 14px !important;
        }

        #imagePreview {
          margin-bottom: 8px !important;
        }

        #previewImg {
          max-width: 150px !important;
          max-height: 100px !important;
        }

        /* 移动端进度条优化 */
        .progress-container {
          padding: 20px !important;
          max-width: 95% !important;
        }

        .progress-title {
          font-size: 16px !important;
        }

        .progress-text {
          font-size: 12px !important;
        }

        .progress-details {
          font-size: 10px !important;
        }

        .cancel-transfer-btn {
          padding: 6px 12px !important;
          font-size: 11px !important;
        }

        .message {
          margin: 10px 0;
          padding: 10px 14px;
          max-width: 85%;
          font-size: 14px;
        }

        .step {
          padding: 15px;
          margin: 15px 0;
        }

        .step h3 {
          font-size: 18px;
        }

        .step p {
          font-size: 13px;
        }
      }

      /* 连接状态控制的显示/隐藏 */
      .connecting-phase .connection-step {
        display: block;
      }
      .connecting-phase .chat-interface {
        opacity: 0.5;
        pointer-events: none;
      }

      .connected-phase .connection-step {
        display: none;
      }
      .connected-phase .chat-interface {
        opacity: 1;
        pointer-events: auto;
      }

      /* 过渡动画 */
      .connection-step,
      .chat-interface {
        transition: all 0.5s ease-in-out;
      }

      /* 连接进度指示器 */
      .connection-progress {
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        border: 2px solid #dee2e6;
        border-radius: 12px;
        padding: 20px;
        margin: 20px 0;
        text-align: center;
        display: none;
      }

      .connection-progress.active {
        display: block;
        animation: pulseProgress 2s infinite;
      }

      @keyframes pulseProgress {
        0%,
        100% {
          transform: scale(1);
          box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
        }
        50% {
          transform: scale(1.02);
          box-shadow: 0 4px 16px rgba(0, 123, 255, 0.4);
        }
      }

      .progress-step {
        margin: 10px 0;
        padding: 8px 0;
        opacity: 0.3;
        transition: opacity 0.3s ease;
      }

      .progress-step.active {
        opacity: 1;
        color: #007bff;
        font-weight: bold;
      }

      .progress-step.completed {
        opacity: 1;
        color: #28a745;
      }

      .progress-step.completed::before {
        content: "✓ ";
        color: #28a745;
        font-weight: bold;
      }

      /* 简化后的聊天界面样式 */
      .simplified-header {
        background: linear-gradient(135deg, #007bff, #0056b3);
        color: white;
        padding: 15px 20px;
        border-radius: 0;
        margin-bottom: 0;
        text-align: center;
        box-shadow: 0 2px 10px rgba(0, 123, 255, 0.3);
        flex-shrink: 0;
      }

      .simplified-header h2 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
      }

      .simplified-header .status-info {
        font-size: 12px;
        opacity: 0.9;
        margin-top: 5px;
      }

      /* 聊天界面布局 */
      .chat-interface {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      .connected-phase .chat-interface {
        height: 100vh;
      }

      /* 输入区域样式 */
      .input-area {
        background: white;
        padding: 15px;
        border-top: 1px solid #dee2e6;
        flex-shrink: 0;
        display: flex;
        gap: 10px;
        align-items: flex-end;
      }

      .input-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .input-row {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      /* 图片传输进度条样式 */
      .progress-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        backdrop-filter: blur(2px);
      }

      .progress-container {
        background: white;
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        max-width: 400px;
        width: 90%;
        text-align: center;
      }

      .progress-title {
        margin: 0 0 20px 0;
        color: #333;
        font-size: 18px;
        font-weight: 600;
      }

      .progress-bar-container {
        background: #f0f0f0;
        border-radius: 10px;
        height: 20px;
        overflow: hidden;
        margin: 15px 0;
        position: relative;
      }

      .progress-bar {
        background: linear-gradient(90deg, #007bff, #0056b3);
        height: 100%;
        width: 0%;
        transition: width 0.3s ease;
        border-radius: 10px;
        position: relative;
        overflow: hidden;
      }

      .progress-bar::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent
        );
        animation: progressShine 2s infinite;
      }

      @keyframes progressShine {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      .progress-text {
        font-size: 14px;
        color: #666;
        margin: 10px 0;
      }

      .progress-details {
        font-size: 12px;
        color: #888;
        margin-top: 10px;
      }

      .cancel-transfer-btn {
        background: #dc3545;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        margin-top: 15px;
      }

      .cancel-transfer-btn:hover {
        background: #c82333;
      }

      /* 房间输入界面样式 */
      .room-input-section {
        background: white;
        border-radius: 16px;
        padding: 30px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        border: 2px solid #28a745;
        max-width: 500px;
        margin: 0 auto;
      }

      .welcome-text h3 {
        color: #28a745;
        margin-bottom: 15px;
        text-align: center;
        font-size: 24px;
        font-weight: 600;
      }

      .welcome-text p {
        color: #666;
        text-align: center;
        margin-bottom: 20px;
        font-size: 16px;
      }

      /* 详细操作区域样式 */
      .details-area {
        animation: slideIn 0.3s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .detail-panel {
        background: #f8f9fa;
        border-radius: 12px;
        padding: 25px;
        margin-bottom: 20px;
        border-left: 4px solid;
      }

      .detail-panel:nth-child(1) {
        border-left-color: #28a745;
      }

      .detail-panel:nth-child(2) {
        border-left-color: #007bff;
      }

      .action-button {
        width: 100%;
        padding: 15px;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        margin: 10px 0;
        transition: all 0.3s ease;
      }

      .action-button.primary {
        background: linear-gradient(135deg, #007bff, #0056b3);
        color: white;
      }

      .action-button.primary:hover {
        background: linear-gradient(135deg, #0056b3, #004494);
        transform: translateY(-2px);
      }

      .action-button.secondary {
        background: linear-gradient(135deg, #28a745, #20c997);
        color: white;
      }

      .action-button.secondary:hover {
        background: linear-gradient(135deg, #20c997, #17a2b8);
        transform: translateY(-2px);
      }

      .action-button:disabled {
        background: #6c757d !important;
        cursor: not-allowed !important;
        transform: none !important;
      }

      .code-area {
        width: 100%;
        min-height: 80px;
        padding: 15px;
        border: 2px solid #dee2e6;
        border-radius: 8px;
        font-family: monospace;
        font-size: 12px;
        resize: vertical;
        margin: 10px 0;
        background: white;
      }

      .code-area:focus {
        border-color: #007bff;
        outline: none;
        box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
      }

      .back-action {
        text-align: center;
        padding-top: 15px;
        border-top: 1px solid #dee2e6;
      }

      .back-button {
        background: none;
        border: 1px solid #6c757d;
        color: #6c757d;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s ease;
      }

      .back-button:hover {
        background: #6c757d;
        color: white;
      }

      /* 房间输入界面响应式 */
      @media (max-width: 768px) {
        .room-input-section {
          padding: 20px;
          margin: 10px;
        }

        .welcome-text h3 {
          font-size: 20px;
        }

        .welcome-text p {
          font-size: 14px;
        }
      }

      /* 简化的进度点样式 */
      .progress-dots {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin: 20px 0;
      }

      .progress-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #dee2e6;
        transition: all 0.3s ease;
        position: relative;
      }

      .progress-dot.active {
        background: #007bff;
        animation: pulse 1.5s infinite;
      }

      .progress-dot.completed {
        background: #28a745;
      }

      .progress-dot.completed::after {
        content: "✓";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 8px;
        font-weight: bold;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.2);
          opacity: 0.7;
        }
      }

      .progress-message {
        text-align: center;
        color: #666;
        font-size: 14px;
        margin-top: 10px;
      }

      /* 连接步骤内容样式 */
      .connection-step-content {
        transition: all 0.3s ease;
      }

      .step-hint {
        background: #e8f5e8;
        border: 1px solid #c3e6c3;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
      }

      .step-hint p {
        margin: 0;
        color: #2d5a2d;
        font-weight: 500;
      }

      /* Toast 提示样式 */
      .toast {
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #28a745, #20c997);
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        z-index: 2000;
        transform: translateX(100%);
        transition: transform 0.3s ease;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .toast.show {
        transform: translateX(0);
      }

      .toast.error {
        background: linear-gradient(135deg, #dc3545, #c82333);
        box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
      }
    </style>
  </head>
  <body>
    <div class="container connecting-phase">
      <!-- 主标题 - 连接后简化 -->
      <h1 id="mainTitle">💬 超简单聊天</h1>

      <!-- 简化后的聊天头部 - 连接前隐藏 -->
      <div
        id="simplifiedHeader"
        class="simplified-header"
        style="display: none"
      >
        <h2 id="chatTitle">💬 聊天已连接</h2>
        <div id="chatSubtitle" class="status-info">
          与朋友的私密聊天，端到端加密
        </div>
      </div>

      <!-- 房间连接区域 - 连接后隐藏 -->
      <div id="connectionStep" class="connection-step">
        <!-- GitHub Token 必填提示 -->
        <div
          id="tokenRequiredSection"
          class="room-input-section"
          style="display: none"
        >
          <div class="welcome-text">
            <h3 style="color: #dc3545; margin-bottom: 15px; text-align: center">
              🔑 需要GitHub Token
            </h3>
            <p style="color: #666; text-align: center; margin-bottom: 20px">
              房间功能需要GitHub Token才能正常工作
            </p>
          </div>

          <div
            style="
              background: #fff3cd;
              border: 1px solid #ffeaa7;
              border-radius: 8px;
              padding: 15px;
              margin-bottom: 20px;
            "
          >
            <div style="font-size: 14px; color: #856404; line-height: 1.5">
              <strong>📖 获取Token步骤：</strong><br />
              1. 访问
              <a
                href="https://github.com/settings/tokens"
                target="_blank"
                style="color: #007bff"
                >GitHub Settings</a
              ><br />
              2. 点击 "Generate new token (classic)"<br />
              3. 只勾选 "gist" 权限<br />
              4. 复制生成的Token粘贴到下方
            </div>
          </div>

          <input
            id="githubTokenRequired"
            type="password"
            class="code-area"
            placeholder="粘贴您的GitHub Token..."
            style="margin-bottom: 15px; font-size: 14px"
          />
          <button
            id="saveToken"
            class="action-button primary"
            style="width: 100%"
          >
            ✅ 保存Token并继续
          </button>
        </div>

        <!-- 主要房间界面 -->
        <div id="roomMainSection" class="room-input-section">
          <div class="welcome-text">
            <h3 style="color: #28a745; margin-bottom: 15px; text-align: center">
              🏠 房间聊天
            </h3>
            <p style="color: #666; text-align: center; margin-bottom: 20px">
              选择创建新房间或加入现有房间
            </p>
          </div>

          <!-- 两个选项：创建房间 vs 加入房间 -->
          <div style="display: flex; gap: 15px; margin-bottom: 20px">
            <div style="flex: 1">
              <button
                id="createRoomBtn"
                class="action-button secondary"
                style="width: 100%; padding: 20px"
              >
                🎯 创建房间<br />
                <small style="font-size: 12px; opacity: 0.8"
                  >生成房间号并等待朋友</small
                >
              </button>
            </div>
            <div style="flex: 1">
              <button
                id="joinRoomBtn"
                class="action-button primary"
                style="width: 100%; padding: 20px"
              >
                🔗 加入房间<br />
                <small style="font-size: 12px; opacity: 0.8"
                  >输入朋友的房间号</small
                >
              </button>
            </div>
          </div>

          <!-- 加入房间的输入区域 -->
          <div id="joinRoomSection" style="display: none">
            <input
              id="roomIdInput"
              type="text"
              class="code-area"
              placeholder="输入朋友的房间号，如：ABC123"
              maxlength="6"
              style="
                text-transform: uppercase;
                text-align: center;
                font-size: 18px;
                letter-spacing: 3px;
                margin-bottom: 15px;
              "
            />
            <button
              id="joinRoom"
              class="action-button primary"
              style="width: 100%"
            >
              🚀 加入房间
            </button>
          </div>

          <div id="roomStatus" class="step-hint" style="display: none">
            <p id="roomStatusText">🔄 正在连接房间...</p>
          </div>
        </div>
      </div>

      <!-- 简化的连接进度指示器 -->
      <div id="connectionProgress" class="connection-progress">
        <h4 style="margin: 0 0 15px 0; color: #333">🔄 正在连接</h4>
        <div class="progress-dots">
          <div id="dot1" class="progress-dot"></div>
          <div id="dot2" class="progress-dot"></div>
          <div id="dot3" class="progress-dot"></div>
          <div id="dot4" class="progress-dot"></div>
        </div>
        <div id="progressMessage" class="progress-message">建立连接中...</div>
      </div>

      <!-- 简化状态指示器 -->
      <div
        id="status"
        class="status"
        style="background: #f8f9fa; color: #666; display: none"
      ></div>

      <!-- 聊天界面 -->
      <div id="chatInterface" class="chat-interface">
        <div id="messages"></div>

        <!-- 输入区域 -->
        <div class="input-area">
          <div class="input-container">
            <!-- 图片预览区域 -->
            <div id="imagePreview" style="display: none; margin-bottom: 10px">
              <div
                style="
                  background: #f8f9fa;
                  border-radius: 8px;
                  padding: 10px;
                  border: 1px solid #dee2e6;
                "
              >
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 8px;
                  "
                >
                  <span style="font-size: 12px; color: #666">📷 图片预览</span>
                  <button
                    id="cancelImage"
                    style="
                      background: none;
                      border: none;
                      color: #dc3545;
                      cursor: pointer;
                      font-size: 16px;
                    "
                  >
                    ✕
                  </button>
                </div>
                <img
                  id="previewImg"
                  style="
                    max-width: 200px;
                    max-height: 150px;
                    border-radius: 6px;
                    display: block;
                  "
                />
                <div
                  id="imageInfo"
                  style="font-size: 11px; color: #888; margin-top: 5px"
                ></div>
              </div>
            </div>

            <div class="input-row">
              <input
                id="messageInput"
                placeholder="输入消息或粘贴图片..."
                disabled
                style="
                  flex: 1;
                  padding: 12px;
                  border: 2px solid #ddd;
                  border-radius: 8px;
                  font-size: 14px;
                  min-height: 20px;
                  resize: none;
                  outline: none;
                "
              />
              <!-- 图片选择按钮 -->
              <button
                id="imageBtn"
                disabled
                title="选择图片"
                style="
                  background-color: #6c757d;
                  color: white;
                  padding: 12px;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  font-size: 16px;
                  min-width: 48px;
                  height: 48px;
                "
              >
                📷
              </button>
              <!-- 发送按钮 -->
              <button
                id="send"
                disabled
                style="
                  background-color: #28a745;
                  color: white;
                  padding: 12px 20px;
                  border: none;
                  border-radius: 8px;
                  font-weight: bold;
                  min-width: 80px;
                  cursor: pointer;
                  height: 48px;
                "
              >
                📤 发送
              </button>
            </div>
          </div>
        </div>

        <!-- 隐藏的文件输入 -->
        <input
          type="file"
          id="fileInput"
          accept="image/*"
          style="display: none"
        />
      </div>
    </div>

    <script>
      const elements = {
        status: document.getElementById("status"),
        messageInput: document.getElementById("messageInput"),
        send: document.getElementById("send"),
        messages: document.getElementById("messages"),
        // UI控制元素
        container: document.querySelector(".container"),
        mainTitle: document.getElementById("mainTitle"),
        simplifiedHeader: document.getElementById("simplifiedHeader"),
        connectionStep: document.getElementById("connectionStep"),
        connectionProgress: document.getElementById("connectionProgress"),
        chatInterface: document.getElementById("chatInterface"),
        // 图片相关元素
        imageBtn: document.getElementById("imageBtn"),
        fileInput: document.getElementById("fileInput"),
        imagePreview: document.getElementById("imagePreview"),
        previewImg: document.getElementById("previewImg"),
        imageInfo: document.getElementById("imageInfo"),
        cancelImage: document.getElementById("cancelImage"),
        // 房间相关元素
        roomIdInput: document.getElementById("roomIdInput"),
        joinRoom: document.getElementById("joinRoom"),
        roomStatus: document.getElementById("roomStatus"),
        roomStatusText: document.getElementById("roomStatusText"),
        chatTitle: document.getElementById("chatTitle"),
        chatSubtitle: document.getElementById("chatSubtitle"),
        // Token相关元素
        githubToken: document.getElementById("githubToken"),
        githubTokenRequired: document.getElementById("githubTokenRequired"),
        saveToken: document.getElementById("saveToken"),
        tokenRequiredSection: document.getElementById("tokenRequiredSection"),
        roomMainSection: document.getElementById("roomMainSection"),
        // 新的房间选择元素
        createRoomBtn: document.getElementById("createRoomBtn"),
        joinRoomBtn: document.getElementById("joinRoomBtn"),
        joinRoomSection: document.getElementById("joinRoomSection"),
      };

      let pc,
        channel,
        currentImage = null, // 当前选择的图片数据
        isTransferring = false, // 是否正在传输
        transferCancelled = false, // 传输是否被取消
        currentRoomId = null, // 当前房间ID
        roomGistId = null; // 房间对应的Gist ID

      // Toast 提示函数
      function showToast(message, type = "success") {
        // 移除现有的toast
        const existingToast = document.querySelector(".toast");
        if (existingToast) {
          existingToast.remove();
        }

        // 创建新的toast
        const toast = document.createElement("div");
        toast.className = `toast ${type}`;

        const icon = type === "success" ? "✅" : "❌";
        toast.innerHTML = `<span>${icon}</span><span>${message}</span>`;

        document.body.appendChild(toast);

        // 显示toast
        setTimeout(() => {
          toast.classList.add("show");
        }, 100);

        // 3秒后隐藏
        setTimeout(() => {
          toast.classList.remove("show");
          setTimeout(() => {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
            }
          }, 300);
        }, 3000);
      }

      // ===== GitHub Token 管理 =====

      // 获取GitHub Token
      function getGitHubToken() {
        // 优先使用输入框中的token（检查元素是否存在）
        if (elements.githubToken && elements.githubToken.value) {
          const inputToken = elements.githubToken.value.trim();
          if (inputToken) {
            // 保存到localStorage
            localStorage.setItem("githubToken", inputToken);
            return inputToken;
          }
        }

        // 从localStorage获取保存的token
        return localStorage.getItem("githubToken") || null;
      }

      // 检查是否有有效的token
      function hasValidToken() {
        const token = getGitHubToken();
        return token && token.length > 10; // 简单验证token格式
      }

      // 清除token
      function clearGitHubToken() {
        localStorage.removeItem("githubToken");
        elements.githubToken.value = "";
      }

      // ===== 纯Gist方案：创建独立的offer和answer Gist =====

      // 创建房间Gist的包装函数
      async function createRoomGist(roomId, roomData) {
        try {
          const headers = {
            "Content-Type": "application/json",
          };

          const token = getGitHubToken();
          if (token) {
            headers["Authorization"] = `Bearer ${token}`;
          }

          const response = await fetch("https://api.github.com/gists", {
            method: "POST",
            headers: headers,
            body: JSON.stringify({
              description: `Chat Room: ${roomId}`,
              public: true, // 改为公开，便于搜索
              files: {
                [`room_${roomId}.json`]: {
                  content: JSON.stringify(roomData),
                },
              },
            }),
          });

          if (!response.ok) {
            if (response.status === 401) {
              const errorMsg = token
                ? "GitHub Token无效，请检查token权限或重新生成"
                : "需要GitHub Token才能创建房间，请在高级选项中配置";
              throw new Error(errorMsg);
            }
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const gist = await response.json();
          const gistId = gist.id;

          // 保存到全局房间列表中
          await addToRoomRegistry(roomId, gistId);

          return gistId;
        } catch (error) {
          console.error("创建房间Gist失败:", error);
          throw error;
        }
      }

      // 读取房间Gist的包装函数
      async function readRoomGist(gistId) {
        try {
          const headers = {};
          const token = getGitHubToken();
          if (token) {
            headers["Authorization"] = `Bearer ${token}`;
          }

          const response = await fetch(
            `https://api.github.com/gists/${gistId}`,
            { headers: headers }
          );

          if (!response.ok) {
            if (response.status === 404) {
              return null;
            }
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const gist = await response.json();
          const fileName = Object.keys(gist.files)[0];
          const content = gist.files[fileName].content;
          return JSON.parse(content);
        } catch (error) {
          console.error("读取房间Gist失败:", error);
          throw error;
        }
      }

      // 添加到房间注册表（更新全局注册表Gist）
      async function addToRoomRegistry(roomId, gistId) {
        try {
          const GLOBAL_REGISTRY_GIST_ID = "55e80e797800fb3d2efd87782db79bb5";

          console.log(`📝 将房间 ${roomId} 添加到全局注册表...`);

          // 读取当前注册表
          let registry;
          try {
            registry = await readRoomGist(GLOBAL_REGISTRY_GIST_ID);
          } catch (error) {
            console.log("注册表不存在或为空，创建新的注册表");
            registry = { rooms: {} };
          }

          if (!registry.rooms) {
            registry.rooms = {};
          }

          // 添加新房间
          registry.rooms[roomId] = {
            gistId: gistId,
            created: Date.now(),
          };

          // 更新注册表Gist（创建新版本，因为无法直接更新）
          const updatedRegistryGistId = await createRoomGist(
            "Global Room Registry",
            { rooms: registry.rooms }
          );

          console.log(
            `📝 房间 ${roomId} 已添加到注册表，新注册表ID: ${updatedRegistryGistId}`
          );

          // 这里有个问题：我们无法让所有人都知道新的注册表ID
          // 所以这个方案还是有缺陷的...
        } catch (error) {
          console.warn("添加到注册表失败:", error);
        }
      }

      // 生成房间码
      function generateRoomId() {
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        let result = "";
        for (let i = 0; i < 6; i++) {
          result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
      }

      // 查找房间的Gist ID（从localStorage缓存中查找）
      function getRoomGistId(roomId) {
        const roomCache = JSON.parse(localStorage.getItem("roomCache") || "{}");
        return roomCache[roomId] || null;
      }

      // 保存房间的Gist ID到缓存
      function saveRoomGistId(roomId, gistId) {
        const roomCache = JSON.parse(localStorage.getItem("roomCache") || "{}");
        roomCache[roomId] = gistId;
        localStorage.setItem("roomCache", JSON.stringify(roomCache));
      }

      // 清除特定房间的缓存
      function clearRoomCache(roomId) {
        const roomCache = JSON.parse(localStorage.getItem("roomCache") || "{}");
        delete roomCache[roomId];
        localStorage.setItem("roomCache", JSON.stringify(roomCache));
      }

      // UI状态管理
      const UIState = {
        INITIAL: "connecting-phase",
        CONNECTING: "connecting-phase",
        CONNECTED: "connected-phase",
      };

      let currentUIState = UIState.INITIAL;

      // 页面加载时初始化token和界面
      function initializeToken() {
        const savedToken = localStorage.getItem("githubToken");

        if (savedToken && savedToken.length > 10) {
          // 有有效Token，显示主界面
          console.log("✅ 找到有效Token，显示主界面");
          showMainInterface();

          if (elements.githubToken) {
            elements.githubToken.value = savedToken;
          }
          if (elements.githubTokenRequired) {
            elements.githubTokenRequired.value = savedToken;
          }
        } else {
          // 没有Token，显示Token输入界面
          console.log("❌ 未找到Token，显示Token输入界面");
          showTokenRequiredInterface();
        }
      }

      // 显示Token必填界面
      function showTokenRequiredInterface() {
        elements.tokenRequiredSection.style.display = "block";
        elements.roomMainSection.style.display = "none";

        setTimeout(() => {
          if (elements.githubTokenRequired) {
            elements.githubTokenRequired.focus();
          }
        }, 500);
      }

      // 显示主界面
      function showMainInterface() {
        elements.tokenRequiredSection.style.display = "none";
        elements.roomMainSection.style.display = "block";
      }

      // 切换UI状态
      function setUIState(state) {
        currentUIState = state;
        elements.container.className = `container ${state}`;

        switch (state) {
          case UIState.CONNECTED:
            // 连接成功后的UI变化
            elements.mainTitle.style.display = "none";
            elements.simplifiedHeader.style.display = "block";
            elements.connectionStep.style.display = "none";
            elements.connectionProgress.classList.remove("active");
            elements.status.style.display = "none";

            // 更新标题显示房间信息
            if (currentRoomId) {
              elements.chatTitle.textContent = `🏠 房间: ${currentRoomId}`;
              elements.chatSubtitle.textContent =
                "🎉 连接成功！与朋友在同一房间聊天";
            }
            break;
          default:
            // 连接前的UI状态
            elements.mainTitle.style.display = "block";
            elements.simplifiedHeader.style.display = "none";
            elements.connectionStep.style.display = "block";
            elements.status.style.display = "block";
        }
      }

      // 更新连接进度
      function updateProgress(stepNumber, status = "active") {
        // 更新进度点
        const dots = [
          document.getElementById("dot1"),
          document.getElementById("dot2"),
          document.getElementById("dot3"),
          document.getElementById("dot4"),
        ];

        const messages = [
          "生成连接码...",
          "建立通道...",
          "安全验证...",
          "启动聊天...",
        ];

        // 重置所有点
        dots.forEach((dot, index) => {
          dot.className = "progress-dot";
          if (index < stepNumber - 1) {
            dot.classList.add("completed");
          } else if (index === stepNumber - 1) {
            dot.classList.add(status);
          }
        });

        // 更新进度消息
        const progressMessage = document.getElementById("progressMessage");
        if (
          progressMessage &&
          stepNumber > 0 &&
          stepNumber <= messages.length
        ) {
          if (status === "completed" && stepNumber === 4) {
            progressMessage.textContent = "连接成功！";
          } else {
            progressMessage.textContent = messages[stepNumber - 1];
          }
        }

        // 显示进度指示器
        if (stepNumber > 0 && stepNumber < 5) {
          elements.connectionProgress.classList.add("active");
        }
      }

      // 更新状态（简化版本）
      function setStatus(text, color = "#666") {
        // 只在必要时显示状态
        if (text && text !== "等待连接...") {
          elements.status.textContent = text;
          elements.status.style.color = color;
          elements.status.style.display = "block";
        } else {
          elements.status.style.display = "none";
        }
      }

      // 图片处理函数
      function compressImage(
        file,
        maxWidth = 800,
        maxHeight = 600,
        quality = 0.8
      ) {
        return new Promise((resolve) => {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          const img = new Image();

          img.onload = () => {
            // 计算压缩后的尺寸
            let { width, height } = img;
            const ratio = Math.min(maxWidth / width, maxHeight / height);

            if (ratio < 1) {
              width *= ratio;
              height *= ratio;
            }

            canvas.width = width;
            canvas.height = height;

            // 绘制并压缩
            ctx.drawImage(img, 0, 0, width, height);
            canvas.toBlob(resolve, "image/jpeg", quality);
          };

          img.src = URL.createObjectURL(file);
        });
      }

      // 处理图片文件
      async function handleImageFile(file) {
        if (!file.type.startsWith("image/")) {
          alert("请选择图片文件！");
          return;
        }

        try {
          // 压缩图片
          const compressedFile = await compressImage(file);

          // 转换为Base64
          const reader = new FileReader();
          reader.onload = (e) => {
            currentImage = {
              data: e.target.result,
              name: file.name,
              size: compressedFile.size,
              type: compressedFile.type,
            };

            // 显示预览
            showImagePreview(currentImage);
          };
          reader.readAsDataURL(compressedFile);
        } catch (error) {
          console.error("图片处理失败:", error);
          alert("图片处理失败，请重试！");
        }
      }

      // 显示图片预览
      function showImagePreview(imageData) {
        elements.previewImg.src = imageData.data;
        elements.imageInfo.textContent = `${imageData.name} (${(
          imageData.size / 1024
        ).toFixed(1)}KB)`;
        elements.imagePreview.style.display = "block";
      }

      // 隐藏图片预览
      function hideImagePreview() {
        elements.imagePreview.style.display = "none";
        currentImage = null;
        elements.fileInput.value = "";
      }

      // 处理粘贴事件
      function handlePaste(e) {
        const items = e.clipboardData?.items;
        if (!items) return;

        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (item.type.startsWith("image/")) {
            e.preventDefault();
            const file = item.getAsFile();
            if (file) {
              handleImageFile(file);
            }
            break;
          }
        }
      }

      // 显示传输进度条
      function showTransferProgress(fileName, fileSize) {
        // 创建进度条覆盖层
        const overlay = document.createElement("div");
        overlay.className = "progress-overlay";
        overlay.id = "progressOverlay";

        overlay.innerHTML = `
          <div class="progress-container">
            <h3 class="progress-title">📤 发送图片</h3>
            <div class="progress-text">正在发送: ${fileName}</div>
            <div class="progress-bar-container">
              <div class="progress-bar" id="progressBar"></div>
            </div>
            <div id="progressText" class="progress-text">0%</div>
            <div class="progress-details">
              <div>文件大小: ${formatFileSize(fileSize)}</div>
              <div id="transferSpeed">传输速度: 计算中...</div>
              <div id="remainingTime">剩余时间: 计算中...</div>
            </div>
            <button class="cancel-transfer-btn" onclick="cancelTransfer()">取消传输</button>
          </div>
        `;

        document.body.appendChild(overlay);
        return overlay;
      }

      // 更新传输进度
      function updateTransferProgress(percentage, speed, remaining) {
        const progressBar = document.getElementById("progressBar");
        const progressText = document.getElementById("progressText");
        const transferSpeed = document.getElementById("transferSpeed");
        const remainingTime = document.getElementById("remainingTime");

        if (progressBar) {
          progressBar.style.width = percentage + "%";
        }
        if (progressText) {
          progressText.textContent = Math.round(percentage) + "%";
        }
        if (transferSpeed && speed) {
          transferSpeed.textContent = `传输速度: ${formatFileSize(speed)}/s`;
        }
        if (remainingTime && remaining) {
          remainingTime.textContent = `剩余时间: ${formatTime(remaining)}`;
        }
      }

      // 隐藏传输进度条
      function hideTransferProgress() {
        const overlay = document.getElementById("progressOverlay");
        if (overlay) {
          document.body.removeChild(overlay);
        }
        isTransferring = false;
        transferCancelled = false;
      }

      // 取消传输
      function cancelTransfer() {
        transferCancelled = true;
        hideTransferProgress();
        alert("图片传输已取消");
      }

      // 格式化文件大小
      function formatFileSize(bytes) {
        if (bytes === 0) return "0 B";
        const k = 1024;
        const sizes = ["B", "KB", "MB", "GB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i];
      }

      // 格式化时间
      function formatTime(seconds) {
        if (!seconds || seconds === Infinity) return "未知";
        if (seconds < 60) return Math.round(seconds) + "秒";
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.round(seconds % 60);
        return `${minutes}分${remainingSeconds}秒`;
      }

      // 分块传输图片数据
      async function sendImageInChunks(imageData, chunkSize = 16384) {
        // 16KB chunks
        const data = JSON.stringify(imageData);
        const totalSize = data.length;
        const totalChunks = Math.ceil(totalSize / chunkSize);

        // 发送传输开始信号
        const transferId = Date.now().toString();
        channel.send(
          JSON.stringify({
            type: "transfer_start",
            transferId: transferId,
            totalChunks: totalChunks,
            totalSize: totalSize,
            fileName: imageData.name,
          })
        );

        let transferredBytes = 0;
        const startTime = Date.now();

        for (let i = 0; i < totalChunks; i++) {
          if (transferCancelled) {
            // 发送取消信号
            channel.send(
              JSON.stringify({
                type: "transfer_cancel",
                transferId: transferId,
              })
            );
            throw new Error("传输已取消");
          }

          const start = i * chunkSize;
          const end = Math.min(start + chunkSize, totalSize);
          const chunk = data.slice(start, end);

          // 发送数据块
          channel.send(
            JSON.stringify({
              type: "transfer_chunk",
              transferId: transferId,
              chunkIndex: i,
              data: chunk,
            })
          );

          transferredBytes += chunk.length;
          const percentage = (transferredBytes / totalSize) * 100;

          // 计算传输速度和剩余时间
          const elapsed = (Date.now() - startTime) / 1000;
          const speed = transferredBytes / elapsed;
          const remaining = (totalSize - transferredBytes) / speed;

          // 更新进度
          updateTransferProgress(percentage, speed, remaining);

          // 给界面一点时间更新
          await new Promise((resolve) => setTimeout(resolve, 1));
        }

        // 发送传输完成信号
        channel.send(
          JSON.stringify({
            type: "transfer_complete",
            transferId: transferId,
          })
        );
      }

      // 接收端传输状态管理
      const receivingTransfers = new Map();

      // 处理传输开始
      function handleTransferStart(data) {
        receivingTransfers.set(data.transferId, {
          totalChunks: data.totalChunks,
          totalSize: data.totalSize,
          fileName: data.fileName,
          receivedChunks: new Array(data.totalChunks),
          receivedCount: 0,
        });

        // 显示接收进度条
        showReceiveProgress(data.fileName, data.totalSize);
      }

      // 处理传输数据块
      function handleTransferChunk(data) {
        const transfer = receivingTransfers.get(data.transferId);
        if (!transfer) return;

        transfer.receivedChunks[data.chunkIndex] = data.data;
        transfer.receivedCount++;

        const percentage =
          (transfer.receivedCount / transfer.totalChunks) * 100;
        updateReceiveProgress(percentage);
      }

      // 处理传输完成
      function handleTransferComplete(data) {
        const transfer = receivingTransfers.get(data.transferId);
        if (!transfer) return;

        // 重组完整数据
        const completeData = transfer.receivedChunks.join("");

        try {
          const imageData = JSON.parse(completeData);
          addMessage(imageData, false);
          hideReceiveProgress();
        } catch (error) {
          console.error("重组图片数据失败:", error);
          alert("接收图片失败");
          hideReceiveProgress();
        }

        receivingTransfers.delete(data.transferId);
      }

      // 处理传输取消
      function handleTransferCancel(data) {
        receivingTransfers.delete(data.transferId);
        hideReceiveProgress();
        alert("对方取消了图片传输");
      }

      // 显示接收进度条
      function showReceiveProgress(fileName, fileSize) {
        const overlay = document.createElement("div");
        overlay.className = "progress-overlay";
        overlay.id = "receiveProgressOverlay";

        overlay.innerHTML = `
          <div class="progress-container">
            <h3 class="progress-title">📥 接收图片</h3>
            <div class="progress-text">正在接收: ${fileName}</div>
            <div class="progress-bar-container">
              <div class="progress-bar" id="receiveProgressBar" style="background: linear-gradient(90deg, #28a745, #20c997);"></div>
            </div>
            <div id="receiveProgressText" class="progress-text">0%</div>
            <div class="progress-details">
              <div>文件大小: ${formatFileSize(fileSize)}</div>
            </div>
          </div>
        `;

        document.body.appendChild(overlay);
      }

      // 更新接收进度
      function updateReceiveProgress(percentage) {
        const progressBar = document.getElementById("receiveProgressBar");
        const progressText = document.getElementById("receiveProgressText");

        if (progressBar) {
          progressBar.style.width = percentage + "%";
        }
        if (progressText) {
          progressText.textContent = Math.round(percentage) + "%";
        }
      }

      // 隐藏接收进度条
      function hideReceiveProgress() {
        const overlay = document.getElementById("receiveProgressOverlay");
        if (overlay) {
          document.body.removeChild(overlay);
        }
      }

      // 显示消息
      function addMessage(content, isMe = false) {
        const div = document.createElement("div");
        div.className = `message ${isMe ? "me" : "them"}`;

        // 创建消息内容
        const messageContent = document.createElement("div");
        messageContent.style.marginBottom = "4px";

        // 检查是否是图片消息
        if (typeof content === "object" && content.type === "image") {
          // 图片消息
          const img = document.createElement("img");
          img.src = content.data;
          img.style.maxWidth = "250px";
          img.style.maxHeight = "200px";
          img.style.borderRadius = "8px";
          img.style.cursor = "pointer";
          img.style.display = "block";

          // 添加图片信息
          const imageInfo = document.createElement("div");
          imageInfo.textContent = content.name;
          imageInfo.style.fontSize = "11px";
          imageInfo.style.opacity = "0.8";
          imageInfo.style.marginTop = "4px";

          // 点击放大图片
          img.onclick = () => {
            const modal = document.createElement("div");
            modal.style.cssText = `
              position: fixed; top: 0; left: 0; width: 100%; height: 100%;
              background: rgba(0,0,0,0.8); display: flex; align-items: center;
              justify-content: center; z-index: 1000; cursor: pointer;
            `;

            const fullImg = document.createElement("img");
            fullImg.src = content.data;
            fullImg.style.cssText = `
              max-width: 90%; max-height: 90%; border-radius: 8px;
              box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            `;

            modal.appendChild(fullImg);
            document.body.appendChild(modal);

            modal.onclick = () => document.body.removeChild(modal);
          };

          messageContent.appendChild(img);
          messageContent.appendChild(imageInfo);
        } else {
          // 文本消息
          messageContent.textContent = content;
        }

        // 创建时间戳
        const timestamp = document.createElement("div");
        const now = new Date();
        timestamp.textContent = now.toLocaleTimeString("zh-CN", {
          hour: "2-digit",
          minute: "2-digit",
        });
        timestamp.style.fontSize = "10px";
        timestamp.style.opacity = "0.7";
        timestamp.style.textAlign = isMe ? "right" : "left";

        div.appendChild(messageContent);
        div.appendChild(timestamp);
        elements.messages.appendChild(div);

        // 平滑滚动到底部
        elements.messages.scrollTo({
          top: elements.messages.scrollHeight,
          behavior: "smooth",
        });
      }

      // 创建连接
      function createConnection() {
        // 使用更稳定的ICE服务器配置
        pc = new RTCPeerConnection({
          iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" },
          ],
          iceCandidatePoolSize: 10,
        });

        pc.onicecandidate = (e) => {
          if (!e.candidate) {
            // 更新进度：生成连接信息完成
            updateProgress(1, "completed");
            updateProgress(2, "active");

            // 房间模式下不需要生成传统连接码
            console.log("房间模式：无需生成传统连接码");

            // 房间模式下不需要传统连接码逻辑
            console.log("房间模式：ICE gathering完成");
          }
        };

        // 统一的连接状态管理
        let connectionStateTimeout;

        pc.onconnectionstatechange = () => {
          // 清除之前的超时，避免状态冲突
          clearTimeout(connectionStateTimeout);

          console.log("连接状态:", pc.connectionState);

          switch (pc.connectionState) {
            case "connecting":
              updateProgress(3, "active");
              break;
            case "connected":
              // 完成所有步骤
              updateProgress(4, "completed");
              console.log("🎉 连接成功！");

              // 延迟切换到聊天界面
              connectionStateTimeout = setTimeout(() => {
                setUIState(UIState.CONNECTED);
              }, 1500);
              break;
            case "disconnected":
              setStatus("连接已断开", "#dc3545");
              elements.connectionProgress.classList.remove("active");
              break;
            case "failed":
              setStatus("连接失败，请重试", "#dc3545");
              elements.connectionProgress.classList.remove("active");
              console.error("连接失败");

              // 延迟显示错误信息，避免立即弹出
              connectionStateTimeout = setTimeout(() => {
                alert("连接失败，请检查网络或重新生成连接码");
              }, 1000);
              break;
          }
        };

        // 简化的ICE状态监控
        pc.oniceconnectionstatechange = () => {
          // 只在关键状态变化时记录
          if (
            pc.iceConnectionState === "failed" ||
            pc.iceConnectionState === "disconnected"
          ) {
            console.log("ICE状态:", pc.iceConnectionState);
          }
        };

        pc.ondatachannel = (e) => {
          channel = e.channel;
          setupChannel();
        };

        return pc;
      }

      // 设置数据通道
      function setupChannel() {
        channel.onopen = () => {
          elements.messageInput.disabled = false;
          elements.send.disabled = false;
          elements.imageBtn.disabled = false;

          // 如果还没有切换到连接状态，这里再次确保切换
          if (currentUIState !== UIState.CONNECTED) {
            updateProgress(4, "completed");
            setTimeout(() => {
              setUIState(UIState.CONNECTED);
            }, 500);
          }
        };

        channel.onmessage = (e) => {
          try {
            // 尝试解析JSON，看是否是传输相关消息
            const data = JSON.parse(e.data);

            // 处理分块传输消息
            if (data.type === "transfer_start") {
              handleTransferStart(data);
            } else if (data.type === "transfer_chunk") {
              handleTransferChunk(data);
            } else if (data.type === "transfer_complete") {
              handleTransferComplete(data);
            } else if (data.type === "transfer_cancel") {
              handleTransferCancel(data);
            } else if (data.type === "image") {
              addMessage(data, false);
            } else {
              addMessage(data.text || e.data, false);
            }
          } catch (err) {
            // 如果解析失败，当作普通文本消息
            addMessage(e.data, false);
          }
        };

        channel.onclose = () => {
          elements.messageInput.disabled = true;
          elements.send.disabled = true;
          elements.imageBtn.disabled = true;
          setStatus("连接已断开", "#dc3545");
        };

        channel.onerror = (error) => {
          console.error("数据通道错误:", error);
          setStatus("通道错误", "#dc3545");
        };
      }

      // 发送消息
      async function sendMessage() {
        const text = elements.messageInput.value.trim();

        if (!channel || channel.readyState !== "open") {
          alert("连接尚未建立，无法发送消息");
          return;
        }

        // 检查是否有图片要发送
        if (currentImage) {
          if (isTransferring) {
            alert("正在传输图片，请稍候...");
            return;
          }

          try {
            isTransferring = true;

            // 构建图片消息
            const imageMessage = {
              type: "image",
              data: currentImage.data,
              name: currentImage.name,
              size: currentImage.size,
            };

            // 如果有文本，添加说明
            if (text) {
              imageMessage.caption = text;
            }

            // 显示进度条
            showTransferProgress(currentImage.name, currentImage.size);

            // 使用分块传输发送图片
            await sendImageInChunks(imageMessage);

            // 传输成功，显示自己发送的消息
            const displayMessage = { ...imageMessage };
            if (text) {
              // 如果有说明文字，先显示图片再显示文字
              addMessage(displayMessage, true);
              addMessage(text, true);
            } else {
              addMessage(displayMessage, true);
            }

            // 隐藏进度条并清理
            hideTransferProgress();
            elements.messageInput.value = "";
            hideImagePreview();
          } catch (error) {
            console.error("发送图片失败:", error);
            hideTransferProgress();
            if (!transferCancelled) {
              alert("发送图片失败: " + error.message);
            }
          }
        } else if (text) {
          try {
            // 发送文本消息
            channel.send(text);

            // 显示自己发送的消息
            addMessage(text, true);
            elements.messageInput.value = "";
          } catch (error) {
            console.error("发送消息失败:", error);
            alert("发送消息失败: " + error.message);
          }
        }
      }

      // ===== 房间连接逻辑 =====

      // 连接到房间
      async function connectToRoom(roomId) {
        if (!roomId || roomId.length !== 6) {
          showToast("请输入6位房间号", "error");
          return;
        }

        roomId = roomId.toUpperCase();
        currentRoomId = roomId;

        // 显示连接状态
        elements.roomStatus.style.display = "block";
        elements.roomStatusText.textContent = "🔄 正在连接房间...";
        elements.joinRoom.disabled = true;

        try {
          // 超简单方案：独立的offer和answer Gist
          console.log(`🔍 检查房间: ${roomId}`);

          // 1. 搜索房间的offer Gist
          const offerGist = await searchOfferGist(roomId);

          if (offerGist) {
            // 找到offer，作为answerer创建answer
            console.log(`✅ 找到房间 ${roomId} 的offer`);
            elements.roomStatusText.textContent = "✅ 找到offer，生成answer...";
            await createAnswerAndConnect(roomId, offerGist);
          } else {
            // 没有offer，作为offerer创建offer
            console.log(`🏗️ 房间 ${roomId} 没有offer，创建offer并等待`);
            elements.roomStatusText.textContent = "🏗️ 创建offer并等待answer...";
            await createOfferAndWait(roomId);
          }
        } catch (error) {
          console.error("房间连接失败:", error);
          elements.roomStatusText.textContent = "❌ 连接失败";
          elements.joinRoom.disabled = false;
          showToast("房间连接失败: " + error.message, "error");
        }
      }

      // 搜索offer Gist（通过文件名搜索）
      async function searchOfferGist(roomId) {
        try {
          const headers = {};
          const token = getGitHubToken();
          if (token) {
            headers["Authorization"] = `Bearer ${token}`;
          }

          // 正确方法：获取公开Gist列表并筛选
          console.log(`🔍 查找房间 ${roomId} 的offer Gist`);

          // 添加GitHub API推荐的headers
          headers["Accept"] = "application/vnd.github+json";
          headers["X-GitHub-Api-Version"] = "2022-11-28";

          const response = await fetch("https://api.github.com/gists/public", {
            headers: headers,
          });

          if (response.ok) {
            const gists = await response.json();
            console.log(`📄 获取到 ${gists.length} 个公开Gist`);

            // 筛选包含我们房间offer的Gist
            for (const gist of gists) {
              // 检查描述
              if (
                gist.description &&
                gist.description.includes(`Room ${roomId} Offer`)
              ) {
                console.log(`✅ 通过描述找到offer Gist: ${gist.id}`);
                return { id: gist.id };
              }

              // 检查文件名
              const files = Object.keys(gist.files);
              if (files.includes(`offer_${roomId}.json`)) {
                console.log(`✅ 通过文件名找到offer Gist: ${gist.id}`);
                return { id: gist.id };
              }
            }
          }

          console.log(`❌ 未找到房间 ${roomId} 的offer`);
          return null;
        } catch (error) {
          console.error("搜索offer失败:", error);
          return null;
        }
      }

      // 创建offer并等待answer
      async function createOfferAndWait(roomId) {
        try {
          // 1. 创建WebRTC offer
          updateProgress(1, "active");
          pc = createConnection();
          channel = pc.createDataChannel("chat");
          setupChannel();

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) resolve();
            };
          });

          const offerTimestamp = Date.now();

          // 2. 创建offer数据
          const offerData = {
            roomId: roomId,
            offer: pc.localDescription,
            timestamp: offerTimestamp,
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          // 3. 创建offer Gist
          const offerGistId = await createRoomGist(
            `Room ${roomId} Offer`,
            offerData,
            `offer_${roomId}.json`
          );

          console.log(`✅ Offer已创建: ${offerGistId}`);
          elements.roomStatusText.textContent = "⏳ 等待其他人加入...";

          // 4. 开始轮询搜索answer
          pollForAnswer(roomId, offerTimestamp);
        } catch (error) {
          console.error("创建offer失败:", error);
          throw error;
        }
      }

      // 创建answer并连接
      async function createAnswerAndConnect(roomId, offerGist) {
        try {
          // 1. 读取offer数据
          const offerData = await readRoomGist(offerGist.id);
          console.log("Offer数据:", offerData);

          // 2. 创建WebRTC连接
          updateProgress(1, "active");
          pc = createConnection();

          await pc.setRemoteDescription(
            new RTCSessionDescription(offerData.offer)
          );
          updateProgress(2, "active");

          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);

          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) resolve();
            };
          });

          // 3. 创建answer数据
          const answerData = {
            roomId: roomId,
            answer: pc.localDescription,
            offerTimestamp: offerData.timestamp,
            timestamp: Date.now(),
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          // 4. 创建answer Gist
          const answerGistId = await createRoomGist(
            `Room ${roomId} Answer`,
            answerData,
            `answer_${roomId}.json`
          );

          console.log(`✅ Answer已创建: ${answerGistId}`);
          updateProgress(3, "active");
          elements.roomStatusText.textContent = "🤝 正在建立连接...";
        } catch (error) {
          console.error("创建answer失败:", error);
          throw error;
        }
      }

      // 轮询搜索answer
      function pollForAnswer(roomId, offerTimestamp) {
        let pollCount = 0;
        const maxPolls = 100;

        const pollInterval = setInterval(async () => {
          try {
            pollCount++;
            elements.roomStatusText.textContent = `⏳ 等待answer... (${Math.ceil(
              pollCount / 20
            )}分钟)`;

            // 搜索answer Gist
            const answerGist = await searchAnswerGist(roomId);

            if (answerGist) {
              clearInterval(pollInterval);

              // 读取answer数据
              const answerData = await readRoomGist(answerGist.id);

              if (answerData && answerData.offerTimestamp === offerTimestamp) {
                await pc.setRemoteDescription(
                  new RTCSessionDescription(answerData.answer)
                );
                updateProgress(3, "active");
                elements.roomStatusText.textContent = "🤝 正在建立连接...";
              }
            }

            if (pollCount >= maxPolls) {
              clearInterval(pollInterval);
              elements.roomStatusText.textContent = "⏰ 等待超时，请重试";
              elements.joinRoom.disabled = false;
            }
          } catch (error) {
            console.error("轮询answer失败:", error);
          }
        }, 3000);
      }

      // 搜索answer Gist
      async function searchAnswerGist(roomId) {
        try {
          const headers = {};
          const token = getGitHubToken();
          if (token) {
            headers["Authorization"] = `Bearer ${token}`;
          }

          // 正确方法：获取公开Gist列表并筛选
          console.log(`🔍 查找房间 ${roomId} 的answer Gist`);

          // 添加GitHub API推荐的headers
          headers["Accept"] = "application/vnd.github+json";
          headers["X-GitHub-Api-Version"] = "2022-11-28";

          const response = await fetch("https://api.github.com/gists/public", {
            headers: headers,
          });

          if (response.ok) {
            const gists = await response.json();
            console.log(`📄 检查 ${gists.length} 个公开Gist寻找answer`);

            // 筛选包含我们房间answer的Gist
            for (const gist of gists) {
              // 检查描述
              if (
                gist.description &&
                gist.description.includes(`Room ${roomId} Answer`)
              ) {
                console.log(`✅ 通过描述找到answer Gist: ${gist.id}`);
                return { id: gist.id };
              }

              // 检查文件名
              const files = Object.keys(gist.files);
              if (files.includes(`answer_${roomId}.json`)) {
                console.log(`✅ 通过文件名找到answer Gist: ${gist.id}`);
                return { id: gist.id };
              }
            }
          }

          console.log(`❌ 未找到房间 ${roomId} 的answer`);
          return null;
        } catch (error) {
          console.error("搜索answer失败:", error);
          return null;
        }
      }

      // 修改createRoomGist支持自定义文件名
      async function createRoomGist(description, data, fileName = "data.json") {
        try {
          const headers = {
            Accept: "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
            "Content-Type": "application/json",
          };

          const token = getGitHubToken();
          if (token) {
            headers["Authorization"] = `Bearer ${token}`;
          }

          const response = await fetch("https://api.github.com/gists", {
            method: "POST",
            headers: headers,
            body: JSON.stringify({
              description: description,
              public: true, // 公开便于搜索
              files: {
                [fileName]: {
                  content: JSON.stringify(data),
                },
              },
            }),
          });

          if (!response.ok) {
            if (response.status === 401) {
              const errorMsg = token
                ? "GitHub Token无效，请检查token权限或重新生成"
                : "需要GitHub Token才能创建房间，请在高级选项中配置";
              throw new Error(errorMsg);
            }
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const gist = await response.json();
          return gist.id;
        } catch (error) {
          console.error("创建Gist失败:", error);

          if (error.message.includes("需要GitHub Token")) {
            const details = document.querySelector("#tokenSection details");
            if (details && !details.open) {
              details.open = true;
              showToast("请配置GitHub Token后重试", "error");
            }
          }

          throw error;
        }
      }

      // 查找房间的offer Gist
      async function findOfferGist(roomId) {
        try {
          // 约定：offer的Gist描述为 "Room ABC123 Offer"
          // 尝试几个可能的offer Gist ID（基于您的账号创建的）
          const possibleOfferGists = [
            "55e80e797800fb3d2efd87782db79bb5", // 您创建的那个
            // 可以添加更多备用的
          ];

          for (const gistId of possibleOfferGists) {
            try {
              console.log(`🔍 检查offer Gist: ${gistId}`);
              const gistData = await readRoomGist(gistId);

              // 检查是否包含我们房间的offer
              if (
                gistData &&
                gistData.roomId === roomId &&
                gistData.offers &&
                gistData.offers.length > 0
              ) {
                console.log(`✅ 找到房间 ${roomId} 的offer`);
                return gistId;
              }
            } catch (error) {
              console.warn(`Gist ${gistId} 读取失败:`, error);
            }
          }

          console.log(`❌ 未找到房间 ${roomId} 的offer`);
          return null;
        } catch (error) {
          console.error("查找offer失败:", error);
          return null;
        }
      }

      // 作为offerer创建房间
      async function createAsOfferer(roomId) {
        try {
          // 创建WebRTC offer
          updateProgress(1, "active");
          pc = createConnection();
          channel = pc.createDataChannel("chat");
          setupChannel();

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) resolve();
            };
          });

          const offerTimestamp = Date.now();

          // 创建房间数据（仍然使用您的固定Gist）
          const roomData = {
            roomId: roomId,
            offers: [
              {
                offer: pc.localDescription,
                timestamp: offerTimestamp,
                userId: "user_" + Math.random().toString(36).substr(2, 9),
              },
            ],
            answers: [],
            created: Date.now(),
          };

          // 但是不能真正更新，只能创建新版本...
          console.log("⚠️ 当前限制：无法更新Gist，数据只能存在内存中");

          roomGistId = "55e80e797800fb3d2efd87782db79bb5"; // 使用固定ID
          elements.roomStatusText.textContent = "⏳ 等待其他人加入...";

          // 简化的轮询：只检查固定Gist
          pollForAnswerSimple(roomId, offerTimestamp);
        } catch (error) {
          console.error("创建offerer失败:", error);
          throw error;
        }
      }

      // 作为answerer加入
      async function joinAsAnswerer(roomId, offerGistId) {
        try {
          // 读取offer数据
          const roomData = await readRoomGist(offerGistId);
          const offer = roomData.offers[0]; // 使用第一个可用的offer

          console.log("🔗 连接到offer:", offer);

          // 创建WebRTC连接
          updateProgress(1, "active");
          pc = createConnection();

          await pc.setRemoteDescription(new RTCSessionDescription(offer.offer));

          updateProgress(2, "active");

          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);

          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) resolve();
            };
          });

          console.log("✅ Answer生成完成，但无法保存到共享Gist");
          console.log("⚠️ 当前限制：无法更新Gist保存answer");

          updateProgress(3, "active");
          elements.roomStatusText.textContent = "🤝 正在建立连接...";
        } catch (error) {
          console.error("作为answerer加入失败:", error);
          throw error;
        }
      }

      // 简化的轮询
      function pollForAnswerSimple(roomId, offerTimestamp) {
        console.log("⚠️ 轮询功能受限：无法真正检查answer");
        // 当前实现下，answer无法被保存，所以轮询无意义
      }

      // 超简单方案：固定Gist ID + 直接读取
      async function tryReadRoomGist(roomId) {
        try {
          // 关键：所有人都使用同一个固定的Gist ID
          const SHARED_GIST_ID = "55e80e797800fb3d2efd87782db79bb5";

          console.log(`📖 读取固定共享Gist: ${SHARED_GIST_ID}`);

          try {
            const sharedData = await readRoomGist(SHARED_GIST_ID);
            console.log("共享Gist内容:", sharedData);

            // 检查这个共享空间是否有我们房间的数据
            if (sharedData && sharedData[roomId]) {
              console.log(`✅ 在共享Gist中找到房间 ${roomId}`);
              return SHARED_GIST_ID; // 返回固定的ID
            } else {
              console.log(`❌ 共享Gist中没有房间 ${roomId}`);
              return null;
            }
          } catch (error) {
            console.error("读取共享Gist失败:", error);
            return null;
          }
        } catch (error) {
          console.error("尝试读取房间失败:", error);
          return null;
        }
      }

      // 创建第一个用户的房间
      async function createFirstUserRoom(roomId) {
        try {
          // 1. 创建WebRTC offer
          updateProgress(1, "active");
          pc = createConnection();
          channel = pc.createDataChannel("chat");
          setupChannel();

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          // 等待ICE gathering完成
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          const offerTimestamp = Date.now();

          // 2. 创建房间数据结构
          const roomData = {
            offer: pc.localDescription,
            offerTimestamp: offerTimestamp,
            answer: null,
            created: Date.now(),
          };

          // 3. 更新固定的共享Gist
          const SHARED_GIST_ID = "55e80e797800fb3d2efd87782db79bb5";

          // 读取当前共享Gist数据
          let sharedData = {};
          try {
            sharedData = (await readRoomGist(SHARED_GIST_ID)) || {};
          } catch (error) {
            console.log("共享Gist为空，初始化新数据");
          }

          // 添加房间数据
          sharedData[roomId] = roomData;

          // ⚠️ 问题：我们无法直接更新现有的Gist（需要创建新版本）
          // 但新版本会有新的ID，其他用户就找不到了！

          console.log(`💾 需要更新共享Gist，但会产生新ID...`);
          console.log("当前方案的限制：无法真正更新Gist，只能创建新版本");

          // 临时方案：将房间数据存储到您的固定Gist中
          // 但这需要您的GitHub账号权限才能更新

          roomGistId = SHARED_GIST_ID; // 使用固定ID

          elements.roomStatusText.textContent = "⏳ 等待其他人加入...";

          // 开始轮询等待answer
          pollForAnswerInSharedGist(roomId, offerTimestamp);
        } catch (error) {
          console.error("创建第一个用户房间失败:", error);
          throw error;
        }
      }

      // 加入现有房间
      async function joinExistingRoom(roomData) {
        try {
          if (!roomData || !roomData.offer) {
            throw new Error("房间数据无效，没有找到offer");
          }

          if (roomData.answer) {
            throw new Error("房间已满，已有其他用户连接");
          }

          console.log("🔗 连接到房间的offer");

          // 创建WebRTC连接
          updateProgress(1, "active");
          pc = createConnection();

          // 设置远程offer
          await pc.setRemoteDescription(
            new RTCSessionDescription(roomData.offer)
          );

          updateProgress(2, "active");

          // 创建answer
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);

          // 等待ICE gathering完成
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          // 更新房间数据，添加answer
          roomData.answer = pc.localDescription;
          roomData.answerTimestamp = Date.now();

          // 更新共享Gist
          const SHARED_GIST_ID = "55e80e797800fb3d2efd87782db79bb5";
          let sharedData = await readRoomGist(SHARED_GIST_ID);
          sharedData[currentRoomId] = roomData;

          const newGistId = await createRoomGist(
            `Shared Chat Rooms`,
            sharedData
          );
          console.log(`✅ Answer已添加到共享Gist: ${newGistId}`);

          // 更新Gist ID
          localStorage.setItem(`room_${currentRoomId}_gist_id`, newGistId);
          roomGistId = newGistId;

          updateProgress(3, "active");
          elements.roomStatusText.textContent = "🤝 正在建立连接...";
        } catch (error) {
          console.error("加入现有房间失败:", error);
          throw error;
        }
      }

      // 在共享Gist中轮询answer
      function pollForAnswerInSharedGist(roomId, offerTimestamp) {
        let pollCount = 0;
        const maxPolls = 100;

        const pollInterval = setInterval(async () => {
          try {
            pollCount++;
            elements.roomStatusText.textContent = `⏳ 等待其他人加入... (${Math.ceil(
              pollCount / 20
            )}分钟)`;

            // 读取最新的共享Gist ID
            const currentGistId = localStorage.getItem(
              `room_${roomId}_gist_id`
            );
            if (currentGistId) {
              const sharedData = await readRoomGist(currentGistId);

              if (
                sharedData &&
                sharedData[roomId] &&
                sharedData[roomId].answer
              ) {
                clearInterval(pollInterval);

                const answer = sharedData[roomId].answer;
                await pc.setRemoteDescription(
                  new RTCSessionDescription(answer)
                );

                updateProgress(3, "active");
                elements.roomStatusText.textContent = "🤝 正在建立连接...";
                return;
              }
            }

            if (pollCount >= maxPolls) {
              clearInterval(pollInterval);
              elements.roomStatusText.textContent = "⏰ 等待超时，请重试";
              elements.joinRoom.disabled = false;
            }
          } catch (error) {
            console.error("轮询共享Gist失败:", error);
          }
        }, 3000);
      }

      // 基于房间号生成固定的Gist ID
      function generateRoomGistId(roomId) {
        // 使用一个固定的算法将房间号转换为32位的hex字符串
        // 这只是示例，实际使用时我们需要一个真实的哈希算法

        // 简单的字符串哈希
        let hash = 0;
        const str = roomId + "CHAT_ROOM_SALT_2025";
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash; // 转换为32位整数
        }

        // 转换为正数并格式化为32位hex字符串
        const positiveHash = Math.abs(hash);
        let hexId = positiveHash.toString(16).padStart(8, "0");

        // 确保是32位hex格式（模拟GitHub Gist ID格式）
        while (hexId.length < 32) {
          hexId = hexId + hexId;
        }
        hexId = hexId.substring(0, 32);

        return hexId;
      }

      // 创建新房间
      async function createNewRoom(roomId) {
        try {
          elements.roomStatusText.textContent = "🎯 创建房间并生成连接信息...";

          // 创建WebRTC连接
          updateProgress(1, "active");
          pc = createConnection();
          channel = pc.createDataChannel("chat");
          setupChannel();

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          // 等待ICE gathering完成
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          const offerTimestamp = Date.now();
          const offerData = {
            type: "offer",
            offer: pc.localDescription,
            timestamp: offerTimestamp,
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          // 创建房间数据
          const roomData = {
            roomId: roomId,
            offers: [offerData],
            answers: [],
            created: Date.now(),
          };

          // 保存房间数据
          const resourceId = await saveRoomData(roomId, roomData);
          roomGistId = `room_${roomId}`; // 使用模拟的ID

          console.log(`🎯 房间 ${roomId} 创建成功, 资源ID: ${resourceId}`);
          elements.roomStatusText.textContent = "⏳ 等待其他人加入...";

          // 开始轮询等待answer
          pollForAnswer(offerTimestamp);
        } catch (error) {
          console.error("创建新房间失败:", error);
          throw error;
        }
      }

      // 加入房间
      async function joinRoom(roomData) {
        try {
          if (!roomData || !roomData.offers) {
            throw new Error("房间数据无效");
          }

          console.log(
            `📊 分析房间数据: offers=${roomData.offers.length}, answers=${
              roomData.answers ? roomData.answers.length : 0
            }`
          );

          // 查找可用的offer（没有对应answer的）
          let availableOffer = null;

          for (const offer of roomData.offers) {
            const hasAnswer =
              roomData.answers &&
              roomData.answers.some(
                (answer) => answer.offerTimestamp === offer.timestamp
              );
            console.log(
              `🔍 检查Offer ${offer.timestamp}: ${
                hasAnswer ? "已有answer" : "可用"
              }`
            );
            if (!hasAnswer) {
              availableOffer = offer;
              break;
            }
          }

          if (availableOffer) {
            // 找到可用offer，作为answerer连接
            console.log(
              `🔗 找到可用offer，作为answerer连接: ${availableOffer.timestamp}`
            );
            elements.roomStatusText.textContent =
              "🔗 找到等待中的用户，正在连接...";
            await connectAsAnswerer(availableOffer);
          } else {
            // 没有可用offer，作为新的offerer
            console.log("💫 没有可用offer，作为新的offerer");
            elements.roomStatusText.textContent = "💫 添加新连接...";
            await addOfferToRoom(roomData);
          }
        } catch (error) {
          console.error("加入房间失败:", error);
          throw error;
        }
      }

      // 作为answerer连接
      async function connectAsAnswerer(offer) {
        try {
          updateProgress(1, "active");

          // 创建WebRTC连接
          pc = createConnection();

          // 设置远程offer
          await pc.setRemoteDescription(new RTCSessionDescription(offer.offer));

          updateProgress(2, "active");

          // 创建answer
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);

          // 等待ICE gathering完成
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          // 准备answer数据
          const answerData = {
            type: "answer",
            answer: pc.localDescription,
            offerTimestamp: offer.timestamp,
            timestamp: Date.now(),
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          // 更新房间数据：添加answer
          await addAnswerToRoom(answerData);

          updateProgress(3, "active");
          elements.roomStatusText.textContent = "🤝 正在建立连接...";
        } catch (error) {
          console.error("作为answerer连接失败:", error);
          throw error;
        }
      }

      // 添加offer到房间
      async function addOfferToRoom(roomData) {
        try {
          // 创建WebRTC连接
          updateProgress(1, "active");
          pc = createConnection();
          channel = pc.createDataChannel("chat");
          setupChannel();

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          // 等待ICE gathering完成
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          const offerTimestamp = Date.now();
          const offerData = {
            type: "offer",
            offer: pc.localDescription,
            timestamp: offerTimestamp,
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          // 更新房间数据
          roomData.offers.push(offerData);

          // 保存更新的房间数据
          await saveRoomData(currentRoomId, roomData);
          console.log(`✅ Offer已添加到房间 ${currentRoomId}`);
          elements.roomStatusText.textContent = "⏳ 等待其他人加入...";

          // 开始轮询等待answer
          pollForAnswer(offerTimestamp);
        } catch (error) {
          console.error("添加offer到房间失败:", error);
          throw error;
        }
      }

      // 添加answer到房间
      async function addAnswerToRoom(answerData) {
        try {
          // 读取当前房间数据
          const roomData = await loadRoomData(currentRoomId);

          // 添加answer
          if (!roomData.answers) roomData.answers = [];
          roomData.answers.push(answerData);

          // 保存更新的房间数据
          await saveRoomData(currentRoomId, roomData);
          console.log(`✅ Answer已添加到房间 ${currentRoomId}`);
        } catch (error) {
          console.error("添加answer到房间失败:", error);
          throw error;
        }
      }

      // 作为第一个用户创建房间
      async function createRoomAsFirstUser(roomId) {
        try {
          elements.roomStatusText.textContent = "🎯 生成连接信息...";

          // 创建WebRTC连接
          updateProgress(1, "active");
          pc = createConnection();
          channel = pc.createDataChannel("chat");
          setupChannel();

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          // 等待ICE gathering完成
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          // 记录offer时间戳
          const offerTimestamp = Date.now();

          // 创建offer数据
          const offerData = {
            type: "offer",
            offer: pc.localDescription,
            timestamp: offerTimestamp,
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          // 上传offer
          await uploadOfferToRoom(offerData);
          elements.roomStatusText.textContent = "⏳ 等待其他人加入...";

          // 开始轮询等待answer
          pollForAnswer(offerTimestamp);
        } catch (error) {
          console.error("创建房间失败:", error);
          throw error;
        }
      }

      // 加入现有offers
      async function joinExistingOffers(offers) {
        try {
          elements.roomStatusText.textContent = "🔍 分析可用连接...";

          // 找到没有answer的offer
          let availableOffer = null;

          for (const offer of offers) {
            const hasAnswer = await checkIfOfferHasAnswer(
              currentRoomId,
              offer.offerTimestamp
            );
            if (!hasAnswer) {
              availableOffer = offer;
              break;
            }
          }

          if (availableOffer) {
            // 找到可用的offer，连接到它
            elements.roomStatusText.textContent =
              "🔗 找到等待中的用户，正在连接...";
            await connectToFoundOffer(availableOffer);
          } else {
            // 所有offer都有answer了，作为新用户创建offer
            elements.roomStatusText.textContent = "💫 创建新连接...";
            await createRoomAsFirstUser(currentRoomId);
          }
        } catch (error) {
          console.error("加入现有offers失败:", error);
          throw error;
        }
      }

      // 创建房间offer
      async function createRoomOffer() {
        try {
          updateProgress(1, "active");

          // 创建WebRTC连接
          pc = createConnection();
          channel = pc.createDataChannel("chat");
          setupChannel();

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          // 等待ICE gathering完成
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          // 记录offer时间戳
          const offerTimestamp = Date.now();

          // 上传offer到房间
          const offerData = {
            type: "offer",
            offer: pc.localDescription,
            timestamp: offerTimestamp,
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          await uploadOfferToRoom(offerData);
          elements.roomStatusText.textContent = "⏳ 等待其他人加入...";

          // 开始轮询等待answer（传入offer时间戳）
          pollForAnswer(offerTimestamp);
        } catch (error) {
          console.error("创建offer失败:", error);
          throw error;
        }
      }

      // 智能加入房间（混合策略）
      async function smartJoinRoom(roomData) {
        try {
          elements.roomStatusText.textContent = "🔍 分析房间状态...";

          // 策略1：首先检查房间主Gist中的offers（更可靠）
          let availableOffers = [];
          if (roomData && roomData.offers && roomData.offers.length > 0) {
            // 检查房间中的offers是否有可用的
            for (const offer of roomData.offers) {
              const hasAnswer =
                roomData.answers &&
                roomData.answers.some(
                  (answer) => answer.offerTimestamp === offer.timestamp
                );
              if (!hasAnswer) {
                availableOffers.push({
                  gistId: null, // 来自主房间
                  offerTimestamp: offer.timestamp,
                  offer: offer,
                });
              }
            }
          }

          // 策略2：如果主Gist中没有可用offers，尝试搜索独立的offer gists
          if (availableOffers.length === 0) {
            elements.roomStatusText.textContent = "🔍 搜索独立连接...";
            const searchOffers = await searchRoomOffers(currentRoomId);

            for (const offer of searchOffers) {
              const hasAnswer = await checkIfOfferHasAnswer(
                currentRoomId,
                offer.offerTimestamp
              );
              if (!hasAnswer) {
                availableOffers.push(offer);
              }
            }
          }

          if (availableOffers.length === 0) {
            // 没有找到任何可用offer，作为新用户创建
            elements.roomStatusText.textContent = "🎯 创建新连接...";
            await createRoomOffer();
            return;
          }

          // 找到可用的offer，连接到最新的一个
          const latestOffer = availableOffers[0]; // 已经按时间排序
          elements.roomStatusText.textContent =
            "🔗 找到等待中的用户，正在连接...";
          await connectToFoundOffer(latestOffer);
        } catch (error) {
          console.error("智能加入房间失败:", error);
          // 降级：直接创建新的offer
          elements.roomStatusText.textContent = "🔄 尝试创建新连接...";
          await createRoomOffer();
        }
      }

      // 检查offer是否已有answer（简化版）
      async function checkIfOfferHasAnswer(roomId, offerTimestamp) {
        try {
          const answerGist = await searchAnswerGist(roomId);
          if (answerGist) {
            // 读取answer数据检查时间戳匹配
            const answerData = await readRoomGist(answerGist.id);
            return answerData && answerData.offerTimestamp === offerTimestamp;
          }
          return false;
        } catch (error) {
          console.error("检查answer失败:", error);
          return false;
        }
      }

      // 连接到找到的offer
      async function connectToFoundOffer(offerInfo) {
        try {
          updateProgress(1, "active");

          // 创建WebRTC连接
          pc = createConnection();

          // 设置远程offer
          await pc.setRemoteDescription(
            new RTCSessionDescription(offerInfo.offer.offer)
          );

          updateProgress(2, "active");

          // 创建answer
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);

          // 等待ICE gathering完成
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          // 上传answer到房间
          const answerData = {
            type: "answer",
            answer: pc.localDescription,
            offerTimestamp: offerInfo.offerTimestamp,
            timestamp: Date.now(),
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          await uploadAnswerToRoom(answerData);

          updateProgress(3, "active");
          elements.roomStatusText.textContent = "🤝 正在建立连接...";
        } catch (error) {
          console.error("连接到找到的offer失败:", error);
          throw error;
        }
      }

      // 上传offer到房间（修复版本）
      async function uploadOfferToRoom(offerData) {
        try {
          // 使用offer的时间戳确保一致性
          const offerTimestamp = offerData.timestamp;
          const offerGistData = {
            roomId: currentRoomId,
            type: "room_offer",
            offer: offerData,
            timestamp: offerTimestamp,
          };

          const offerGistId = await createGist(
            `Chat Room: ${currentRoomId} - Offer ${offerTimestamp}`,
            `offer_${currentRoomId}_${offerTimestamp}.json`,
            offerGistData
          );

          // 保存offer的Gist ID，用于后续检查
          const offerCache = JSON.parse(
            localStorage.getItem("offerCache") || "{}"
          );
          if (!offerCache[currentRoomId]) {
            offerCache[currentRoomId] = [];
          }
          offerCache[currentRoomId].push({
            gistId: offerGistId,
            timestamp: offerTimestamp,
            offerTimestamp: offerTimestamp,
          });
          localStorage.setItem("offerCache", JSON.stringify(offerCache));

          console.log(`Offer uploaded to Gist: ${offerGistId}`);

          // 同时保存到房间的主Gist中（作为备份）
          await updateRoomWithOffer(offerData);
        } catch (error) {
          console.error("上传offer失败:", error);
          throw error;
        }
      }

      // 更新房间主Gist（添加offer作为备份）
      async function updateRoomWithOffer(offerData) {
        try {
          if (!roomGistId) return;

          // 读取当前房间数据
          const roomData = await readGist(roomGistId);
          if (roomData) {
            // 添加offer到房间数据中
            if (!roomData.offers) roomData.offers = [];
            roomData.offers.push(offerData);

            // 创建新的房间Gist
            const newRoomGistId = await createGist(
              `Chat Room: ${currentRoomId} - Updated`,
              `room_${currentRoomId}.json`,
              roomData
            );

            // 更新缓存
            saveRoomGistId(currentRoomId, newRoomGistId);
            roomGistId = newRoomGistId;
          }
        } catch (error) {
          console.warn("更新房间主Gist失败:", error);
          // 不抛出错误，因为这只是备份
        }
      }

      // 上传answer到房间（优化版本）
      async function uploadAnswerToRoom(answerData) {
        try {
          // 创建包含answer的独立Gist
          const timestamp = Date.now();
          const answerGistData = {
            roomId: currentRoomId,
            type: "room_answer",
            answer: answerData,
            timestamp: timestamp,
          };

          const answerGistId = await createGist(
            `Chat Room: ${currentRoomId} - Answer ${timestamp}`,
            `answer_${currentRoomId}_${answerData.offerTimestamp}.json`,
            answerGistData
          );

          console.log(`Answer uploaded to Gist: ${answerGistId}`);

          // 同时保存到房间的主Gist中（作为备份）
          await updateRoomWithAnswer(answerData);
        } catch (error) {
          console.error("上传answer失败:", error);
          throw error;
        }
      }

      // 更新房间主Gist（添加answer作为备份）
      async function updateRoomWithAnswer(answerData) {
        try {
          if (!roomGistId) return;

          // 读取当前房间数据
          const roomData = await readGist(roomGistId);
          if (roomData) {
            // 添加answer到房间数据中
            if (!roomData.answers) roomData.answers = [];
            roomData.answers.push(answerData);

            // 创建新的房间Gist
            const newRoomGistId = await createGist(
              `Chat Room: ${currentRoomId} - Complete`,
              `room_${currentRoomId}.json`,
              roomData
            );

            // 更新缓存
            saveRoomGistId(currentRoomId, newRoomGistId);
            roomGistId = newRoomGistId;
          }
        } catch (error) {
          console.warn("更新房间主Gist失败:", error);
          // 不抛出错误，因为这只是备份
        }
      }

      // 轮询等待answer（纯Gist方案）
      function pollForAnswer(roomId, myOfferTimestamp) {
        let pollCount = 0;
        const maxPolls = 100; // 最多轮询100次 (5分钟)

        const pollInterval = setInterval(async () => {
          try {
            pollCount++;
            elements.roomStatusText.textContent = `⏳ 等待answer... (${Math.ceil(
              pollCount / 20
            )}分钟)`;

            // 搜索answer Gist
            const answerGist = await searchAnswerGist(roomId);

            if (answerGist) {
              clearInterval(pollInterval);

              // 读取answer数据
              const answerData = await readRoomGist(answerGist.id);
              console.log("找到answer数据:", answerData);

              if (
                answerData &&
                answerData.offerTimestamp === myOfferTimestamp
              ) {
                // 设置远程answer
                await pc.setRemoteDescription(
                  new RTCSessionDescription(answerData.answer)
                );

                updateProgress(3, "active");
                elements.roomStatusText.textContent = "🤝 正在建立连接...";
                return;
              }
            }

            if (pollCount >= maxPolls) {
              clearInterval(pollInterval);
              elements.roomStatusText.textContent = "⏰ 等待超时，请重试";
              elements.joinRoom.disabled = false;
            }
          } catch (error) {
            console.error("轮询answer失败:", error);
            // 继续轮询，不中断
          }
        }, 3000); // 每3秒轮询一次
      }

      // 事件绑定

      // Token保存事件
      elements.saveToken.onclick = () => {
        const token = elements.githubTokenRequired.value.trim();
        if (token && token.length > 10) {
          localStorage.setItem("githubToken", token);
          showToast("Token已保存！");
          showMainInterface();
        } else {
          showToast("请输入有效的GitHub Token", "error");
        }
      };

      // Token输入框回车事件
      elements.githubTokenRequired.onkeypress = (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          elements.saveToken.click();
        }
      };

      // 创建房间按钮事件
      elements.createRoomBtn.onclick = async () => {
        const newRoomId = generateRoomId();
        showToast(`房间号已生成: ${newRoomId}`);

        // 自动复制房间号
        try {
          await navigator.clipboard.writeText(newRoomId);
          showToast(`房间号 ${newRoomId} 已复制到剪贴板！`);
        } catch (error) {
          console.warn("自动复制失败:", error);
        }

        // 自动连接到房间
        currentRoomId = newRoomId;
        elements.roomStatus.style.display = "block";
        elements.roomStatusText.textContent = "🎯 创建房间中...";

        await createOfferAndWait(newRoomId);
      };

      // 加入房间按钮事件
      elements.joinRoomBtn.onclick = () => {
        elements.joinRoomSection.style.display = "block";
        setTimeout(() => {
          elements.roomIdInput.focus();
        }, 100);
      };

      // 加入房间确认事件
      elements.joinRoom.onclick = async () => {
        const roomId = elements.roomIdInput.value.trim();
        await connectToRoom(roomId);
      };

      // 房间号输入框回车事件
      elements.roomIdInput.onkeypress = (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          elements.joinRoom.click();
        }
      };

      // 房间号输入框自动格式化
      elements.roomIdInput.oninput = (e) => {
        let value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, "");
        if (value.length > 6) value = value.substring(0, 6);
        e.target.value = value;
      };

      elements.send.onclick = sendMessage;
      elements.messageInput.onkeypress = (e) => {
        if (e.key === "Enter") sendMessage();
      };

      // 图片相关事件绑定
      elements.imageBtn.onclick = () => {
        elements.fileInput.click();
      };

      elements.fileInput.onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
          handleImageFile(file);
        }
      };

      elements.cancelImage.onclick = hideImagePreview;

      // 绑定粘贴事件
      elements.messageInput.addEventListener("paste", handlePaste);
      document.addEventListener("paste", (e) => {
        // 只有当输入框获得焦点或者没有其他输入框时才处理粘贴
        if (
          document.activeElement === elements.messageInput ||
          !document.activeElement ||
          document.activeElement === document.body
        ) {
          handlePaste(e);
        }
      });

      // 键盘快捷键支持（简化版）
      document.addEventListener("keydown", (e) => {
        // 在房间号输入框中按回车自动连接
        if (
          e.key === "Enter" &&
          document.activeElement === elements.roomIdInput
        ) {
          e.preventDefault();
          elements.joinRoom.click();
        }
      });

      // 调试函数：显示房间状态
      window.debugRoom = async function (roomId) {
        console.log(`=== 房间 ${roomId} 调试信息 ===`);

        try {
          // 搜索房间Gist
          const roomGist = await findRoomGist(roomId);
          if (roomGist) {
            console.log("找到房间Gist ID:", roomGist.id);
            const roomData = await readGist(roomGist.id);
            console.log("房间数据:", roomData);

            if (roomData.offers) {
              console.log(`房间内有 ${roomData.offers.length} 个offers:`);
              roomData.offers.forEach((offer, index) => {
                const hasAnswer =
                  roomData.answers &&
                  roomData.answers.some(
                    (answer) => answer.offerTimestamp === offer.timestamp
                  );
                console.log(
                  `  Offer ${index + 1} (${offer.timestamp}): ${
                    hasAnswer ? "已有answer" : "等待answer"
                  }`
                );
              });
            }

            if (roomData.answers) {
              console.log(`房间内有 ${roomData.answers.length} 个answers`);
            }
          } else {
            console.log("没有找到房间，房间不存在或搜索失败");
          }

          // 显示当前连接状态
          console.log("当前房间ID:", currentRoomId);
          console.log("当前房间Gist ID:", roomGistId);
          console.log("WebRTC连接状态:", pc ? pc.connectionState : "未创建");
        } catch (error) {
          console.error("调试失败:", error);
        }
      };

      // 清除缓存的调试函数
      window.clearRoomCache = function () {
        localStorage.clear();
        console.log("已清除所有缓存");
      };

      // 页面加载完成后初始化
      document.addEventListener("DOMContentLoaded", () => {
        initializeToken();

        // 开发模式提示
        console.log("🔧 调试提示:");
        console.log("  debugRoom('房间号') - 查看房间状态");
        console.log("  clearRoomCache() - 清除所有缓存");
      });
    </script>
  </body>
</html>
