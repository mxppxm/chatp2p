<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <title>è¶…ç®€å•èŠå¤©</title>
    <style>
      * {
        box-sizing: border-box; /* å…¨å±€è®¾ç½®ï¼Œé¿å…å…ƒç´ è¶…å‡º */
      }

      body {
        font-family: Arial, sans-serif;
        padding: 0;
        margin: 0;
        background: #f5f5f5;
        height: 100vh;
        overflow: hidden;
      }
      .container {
        background: white;
        padding: 20px;
        height: 100vh;
        display: flex;
        flex-direction: column;
        border-radius: 0;
        box-shadow: none;
      }

      /* è¿æ¥é˜¶æ®µçš„å®¹å™¨æ ·å¼ */
      .container.connecting-phase {
        max-width: 800px;
        margin: 0 auto;
        height: auto;
        min-height: 100vh;
        border-radius: 0;
        padding: 20px;
      }

      /* å·²è¿æ¥çŠ¶æ€çš„å®¹å™¨æ ·å¼ */
      .container.connected-phase {
        padding: 0;
        max-width: none;
        width: 100%;
      }
      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
      }
      .step {
        background: #f8f9fa;
        padding: 20px;
        margin: 20px 0;
        border-radius: 10px;
        border-left: 5px solid #007bff;
      }
      button {
        background: #007bff;
        color: white;
        border: none;
        padding: 15px 25px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        margin: 5px;
      }
      button:hover {
        background: #0056b3;
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      textarea {
        width: 100%;
        height: 60px;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 5px;
        margin: 10px 0;
        font-family: monospace;
        font-size: 12px;
        resize: none;
      }
      #messages {
        background: #ffffff;
        border: 2px solid #e0e0e0;
        border-radius: 15px;
        height: 300px;
        overflow-y: auto;
        padding: 20px;
        margin: 20px 0;
        box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05);
        flex: 1;
      }

      /* è¿æ¥çŠ¶æ€ä¸‹çš„æ¶ˆæ¯åŒºåŸŸæ ·å¼ */
      .connected-phase #messages {
        height: auto;
        flex: 1;
        margin: 0;
        border: none;
        border-radius: 0;
        background: #f8f9fa;
        box-shadow: none;
        padding: 15px;
      }
      .message {
        margin: 12px 0;
        padding: 12px 16px;
        border-radius: 18px;
        max-width: 75%;
        word-wrap: break-word;
        position: relative;
        animation: fadeIn 0.3s ease-out;
      }
      .me {
        background: linear-gradient(135deg, #007bff, #0056b3);
        color: white;
        margin-left: auto;
        text-align: right;
        box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
      }
      .me::after {
        content: "";
        position: absolute;
        right: -8px;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border: 8px solid transparent;
        border-left-color: #007bff;
      }
      .them {
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        color: #333;
        border: 1px solid #dee2e6;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .them::after {
        content: "";
        position: absolute;
        left: -8px;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border: 8px solid transparent;
        border-right-color: #f8f9fa;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* èŠå¤©æ¡†ä¸ºç©ºæ—¶çš„æç¤º */
      #messages:empty::before {
        content: "ğŸ’¬ èŠå¤©æ¶ˆæ¯ä¼šåœ¨è¿™é‡Œæ˜¾ç¤º...";
        color: #999;
        font-style: italic;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        text-align: center;
      }
      #messageInput {
        width: 70%;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 5px;
        margin-right: 10px;
      }
      .status {
        text-align: center;
        padding: 10px;
        border-radius: 5px;
        margin: 15px 0;
        font-weight: bold;
      }
      .flex {
        display: flex;
        align-items: center;
      }

      /* ä¼˜åŒ–è¿æ¥åŒºåŸŸå¸ƒå±€ */
      .connection-area {
        display: flex;
        gap: 20px;
        margin: 20px 0;
      }

      .connection-box {
        flex: 1;
        border: 2px dashed;
        padding: 20px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.8);
      }

      .connection-box h4 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 16px;
      }

      .connection-box button {
        width: 100%;
        margin-bottom: 12px;
        padding: 12px;
        font-size: 14px;
      }

      .connection-box textarea {
        width: 100%;
        margin-top: 10px;
        padding: 12px;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-family: monospace;
        font-size: 11px;
        resize: none;
        min-height: 80px;
      }

      /* å“åº”å¼è®¾è®¡ */
      @media (max-width: 768px) {
        body {
          padding: 10px;
        }

        .container {
          padding: 20px;
        }

        h1 {
          font-size: 24px;
          margin-bottom: 20px;
        }

        .connection-area {
          flex-direction: column;
          gap: 15px;
        }

        .connection-box {
          padding: 15px;
        }

        .connection-box h4 {
          font-size: 14px;
        }

        .connection-box button {
          padding: 10px;
          font-size: 13px;
        }

        .connection-box textarea {
          min-height: 60px;
          font-size: 10px;
        }

        .connection-progress {
          padding: 15px;
          margin: 15px 0;
        }

        .connection-progress h4 {
          font-size: 16px;
        }

        .progress-step {
          font-size: 13px;
          margin: 8px 0;
          padding: 6px 0;
        }

        .simplified-header {
          padding: 12px 15px;
          margin-bottom: 15px;
        }

        .simplified-header h2 {
          font-size: 16px;
        }

        .simplified-header .status-info {
          font-size: 11px;
        }

        #messageInput {
          font-size: 16px; /* é˜²æ­¢iOSæ”¾å¤§ */
          padding: 10px !important;
        }

        #send {
          padding: 10px 15px !important;
          font-size: 13px !important;
          min-width: 60px !important;
        }

        #messages {
          height: 250px;
          padding: 15px;
        }

        .connected-phase #messages {
          padding: 10px;
        }

        .input-area {
          padding: 10px !important;
        }

        .input-row {
          gap: 8px !important;
        }

        #imageBtn {
          min-width: 40px !important;
          height: 40px !important;
          padding: 8px !important;
          font-size: 14px !important;
        }

        #imagePreview {
          margin-bottom: 8px !important;
        }

        #previewImg {
          max-width: 150px !important;
          max-height: 100px !important;
        }

        /* ç§»åŠ¨ç«¯è¿›åº¦æ¡ä¼˜åŒ– */
        .progress-container {
          padding: 20px !important;
          max-width: 95% !important;
        }

        .progress-title {
          font-size: 16px !important;
        }

        .progress-text {
          font-size: 12px !important;
        }

        .progress-details {
          font-size: 10px !important;
        }

        .cancel-transfer-btn {
          padding: 6px 12px !important;
          font-size: 11px !important;
        }

        .message {
          margin: 10px 0;
          padding: 10px 14px;
          max-width: 85%;
          font-size: 14px;
        }

        .step {
          padding: 15px;
          margin: 15px 0;
        }

        .step h3 {
          font-size: 18px;
        }

        .step p {
          font-size: 13px;
        }
      }

      /* è¿æ¥çŠ¶æ€æ§åˆ¶çš„æ˜¾ç¤º/éšè— */
      .connecting-phase .connection-step {
        display: block;
      }
      .connecting-phase .chat-interface {
        opacity: 0.5;
        pointer-events: none;
      }

      .connected-phase .connection-step {
        display: none;
      }
      .connected-phase .chat-interface {
        opacity: 1;
        pointer-events: auto;
      }

      /* è¿‡æ¸¡åŠ¨ç”» */
      .connection-step,
      .chat-interface {
        transition: all 0.5s ease-in-out;
      }

      /* è¿æ¥è¿›åº¦æŒ‡ç¤ºå™¨ */
      .connection-progress {
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        border: 2px solid #dee2e6;
        border-radius: 12px;
        padding: 20px;
        margin: 20px 0;
        text-align: center;
        display: none;
      }

      .connection-progress.active {
        display: block;
        animation: pulseProgress 2s infinite;
      }

      @keyframes pulseProgress {
        0%,
        100% {
          transform: scale(1);
          box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
        }
        50% {
          transform: scale(1.02);
          box-shadow: 0 4px 16px rgba(0, 123, 255, 0.4);
        }
      }

      .progress-step {
        margin: 10px 0;
        padding: 8px 0;
        opacity: 0.3;
        transition: opacity 0.3s ease;
      }

      .progress-step.active {
        opacity: 1;
        color: #007bff;
        font-weight: bold;
      }

      .progress-step.completed {
        opacity: 1;
        color: #28a745;
      }

      .progress-step.completed::before {
        content: "âœ“ ";
        color: #28a745;
        font-weight: bold;
      }

      /* ç®€åŒ–åçš„èŠå¤©ç•Œé¢æ ·å¼ */
      .simplified-header {
        background: linear-gradient(135deg, #007bff, #0056b3);
        color: white;
        padding: 15px 20px;
        border-radius: 0;
        margin-bottom: 0;
        text-align: center;
        box-shadow: 0 2px 10px rgba(0, 123, 255, 0.3);
        flex-shrink: 0;
      }

      .simplified-header h2 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
      }

      .simplified-header .status-info {
        font-size: 12px;
        opacity: 0.9;
        margin-top: 5px;
      }

      /* èŠå¤©ç•Œé¢å¸ƒå±€ */
      .chat-interface {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      .connected-phase .chat-interface {
        height: 100vh;
      }

      /* è¾“å…¥åŒºåŸŸæ ·å¼ */
      .input-area {
        background: white;
        padding: 15px;
        border-top: 1px solid #dee2e6;
        flex-shrink: 0;
        display: flex;
        gap: 10px;
        align-items: flex-end;
      }

      .input-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .input-row {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      /* å›¾ç‰‡ä¼ è¾“è¿›åº¦æ¡æ ·å¼ */
      .progress-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        backdrop-filter: blur(2px);
      }

      .progress-container {
        background: white;
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        max-width: 400px;
        width: 90%;
        text-align: center;
      }

      .progress-title {
        margin: 0 0 20px 0;
        color: #333;
        font-size: 18px;
        font-weight: 600;
      }

      .progress-bar-container {
        background: #f0f0f0;
        border-radius: 10px;
        height: 20px;
        overflow: hidden;
        margin: 15px 0;
        position: relative;
      }

      .progress-bar {
        background: linear-gradient(90deg, #007bff, #0056b3);
        height: 100%;
        width: 0%;
        transition: width 0.3s ease;
        border-radius: 10px;
        position: relative;
        overflow: hidden;
      }

      .progress-bar::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent
        );
        animation: progressShine 2s infinite;
      }

      @keyframes progressShine {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      .progress-text {
        font-size: 14px;
        color: #666;
        margin: 10px 0;
      }

      .progress-details {
        font-size: 12px;
        color: #888;
        margin-top: 10px;
      }

      .cancel-transfer-btn {
        background: #dc3545;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        margin-top: 15px;
      }

      .cancel-transfer-btn:hover {
        background: #c82333;
      }

      /* æˆ¿é—´è¾“å…¥ç•Œé¢æ ·å¼ */
      .room-input-section {
        background: white;
        border-radius: 16px;
        padding: 30px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        border: 2px solid #28a745;
        max-width: 500px;
        margin: 0 auto;
      }

      .welcome-text h3 {
        color: #28a745;
        margin-bottom: 15px;
        text-align: center;
        font-size: 24px;
        font-weight: 600;
      }

      .welcome-text p {
        color: #666;
        text-align: center;
        margin-bottom: 20px;
        font-size: 16px;
      }

      /* è¯¦ç»†æ“ä½œåŒºåŸŸæ ·å¼ */
      .details-area {
        animation: slideIn 0.3s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .detail-panel {
        background: #f8f9fa;
        border-radius: 12px;
        padding: 25px;
        margin-bottom: 20px;
        border-left: 4px solid;
      }

      .detail-panel:nth-child(1) {
        border-left-color: #28a745;
      }

      .detail-panel:nth-child(2) {
        border-left-color: #007bff;
      }

      .action-button {
        width: 100%;
        padding: 15px;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        margin: 10px 0;
        transition: all 0.3s ease;
      }

      .action-button.primary {
        background: linear-gradient(135deg, #007bff, #0056b3);
        color: white;
      }

      .action-button.primary:hover {
        background: linear-gradient(135deg, #0056b3, #004494);
        transform: translateY(-2px);
      }

      .action-button.secondary {
        background: linear-gradient(135deg, #28a745, #20c997);
        color: white;
      }

      .action-button.secondary:hover {
        background: linear-gradient(135deg, #20c997, #17a2b8);
        transform: translateY(-2px);
      }

      .action-button:disabled {
        background: #6c757d !important;
        cursor: not-allowed !important;
        transform: none !important;
      }

      .code-area {
        width: 100%;
        min-height: 80px;
        padding: 15px;
        border: 2px solid #dee2e6;
        border-radius: 8px;
        font-family: monospace;
        font-size: 12px;
        resize: vertical;
        margin: 10px 0;
        background: white;
      }

      .code-area:focus {
        border-color: #007bff;
        outline: none;
        box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
      }

      .back-action {
        text-align: center;
        padding-top: 15px;
        border-top: 1px solid #dee2e6;
      }

      .back-button {
        background: none;
        border: 1px solid #6c757d;
        color: #6c757d;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s ease;
      }

      .back-button:hover {
        background: #6c757d;
        color: white;
      }

      /* æˆ¿é—´è¾“å…¥ç•Œé¢å“åº”å¼ */
      @media (max-width: 768px) {
        .room-input-section {
          padding: 20px;
          margin: 10px;
        }

        .welcome-text h3 {
          font-size: 20px;
        }

        .welcome-text p {
          font-size: 14px;
        }
      }

      /* ç®€åŒ–çš„è¿›åº¦ç‚¹æ ·å¼ */
      .progress-dots {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin: 20px 0;
      }

      .progress-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #dee2e6;
        transition: all 0.3s ease;
        position: relative;
      }

      .progress-dot.active {
        background: #007bff;
        animation: pulse 1.5s infinite;
      }

      .progress-dot.completed {
        background: #28a745;
      }

      .progress-dot.completed::after {
        content: "âœ“";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 8px;
        font-weight: bold;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.2);
          opacity: 0.7;
        }
      }

      .progress-message {
        text-align: center;
        color: #666;
        font-size: 14px;
        margin-top: 10px;
      }

      /* è¿æ¥æ­¥éª¤å†…å®¹æ ·å¼ */
      .connection-step-content {
        transition: all 0.3s ease;
      }

      .step-hint {
        background: #e8f5e8;
        border: 1px solid #c3e6c3;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
      }

      .step-hint p {
        margin: 0;
        color: #2d5a2d;
        font-weight: 500;
      }

      /* Toast æç¤ºæ ·å¼ */
      .toast {
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #28a745, #20c997);
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        z-index: 2000;
        transform: translateX(100%);
        transition: transform 0.3s ease;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .toast.show {
        transform: translateX(0);
      }

      .toast.error {
        background: linear-gradient(135deg, #dc3545, #c82333);
        box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
      }
    </style>
  </head>
  <body>
    <div class="container connecting-phase">
      <!-- ä¸»æ ‡é¢˜ - è¿æ¥åç®€åŒ– -->
      <h1 id="mainTitle">ğŸ’¬ è¶…ç®€å•èŠå¤©</h1>

      <!-- ç®€åŒ–åçš„èŠå¤©å¤´éƒ¨ - è¿æ¥å‰éšè— -->
      <div
        id="simplifiedHeader"
        class="simplified-header"
        style="display: none"
      >
        <h2 id="chatTitle">ğŸ’¬ èŠå¤©å·²è¿æ¥</h2>
        <div id="chatSubtitle" class="status-info">
          ä¸æœ‹å‹çš„ç§å¯†èŠå¤©ï¼Œç«¯åˆ°ç«¯åŠ å¯†
        </div>
      </div>

      <!-- æˆ¿é—´è¿æ¥åŒºåŸŸ - è¿æ¥åéšè— -->
      <div id="connectionStep" class="connection-step">
        <!-- GitHub Token å¿…å¡«æç¤º -->
        <div
          id="tokenRequiredSection"
          class="room-input-section"
          style="display: none"
        >
          <div class="welcome-text">
            <h3 style="color: #dc3545; margin-bottom: 15px; text-align: center">
              ğŸ”‘ éœ€è¦GitHub Token
            </h3>
            <p style="color: #666; text-align: center; margin-bottom: 20px">
              æˆ¿é—´åŠŸèƒ½éœ€è¦GitHub Tokenæ‰èƒ½æ­£å¸¸å·¥ä½œ
            </p>
          </div>

          <div
            style="
              background: #fff3cd;
              border: 1px solid #ffeaa7;
              border-radius: 8px;
              padding: 15px;
              margin-bottom: 20px;
            "
          >
            <div style="font-size: 14px; color: #856404; line-height: 1.5">
              <strong>ğŸ“– è·å–Tokenæ­¥éª¤ï¼š</strong><br />
              1. è®¿é—®
              <a
                href="https://github.com/settings/tokens"
                target="_blank"
                style="color: #007bff"
                >GitHub Settings</a
              ><br />
              2. ç‚¹å‡» "Generate new token (classic)"<br />
              3. åªå‹¾é€‰ "gist" æƒé™<br />
              4. å¤åˆ¶ç”Ÿæˆçš„Tokenç²˜è´´åˆ°ä¸‹æ–¹
            </div>
          </div>

          <input
            id="githubTokenRequired"
            type="password"
            class="code-area"
            placeholder="ç²˜è´´æ‚¨çš„GitHub Token..."
            style="margin-bottom: 15px; font-size: 14px"
          />
          <button
            id="saveToken"
            class="action-button primary"
            style="width: 100%"
          >
            âœ… ä¿å­˜Tokenå¹¶ç»§ç»­
          </button>
        </div>

        <!-- ä¸»è¦æˆ¿é—´ç•Œé¢ -->
        <div id="roomMainSection" class="room-input-section">
          <div class="welcome-text">
            <h3 style="color: #28a745; margin-bottom: 15px; text-align: center">
              ğŸ  æˆ¿é—´èŠå¤©
            </h3>
            <p style="color: #666; text-align: center; margin-bottom: 20px">
              é€‰æ‹©åˆ›å»ºæ–°æˆ¿é—´æˆ–åŠ å…¥ç°æœ‰æˆ¿é—´
            </p>
          </div>

          <!-- ä¸¤ä¸ªé€‰é¡¹ï¼šåˆ›å»ºæˆ¿é—´ vs åŠ å…¥æˆ¿é—´ -->
          <div style="display: flex; gap: 15px; margin-bottom: 20px">
            <div style="flex: 1">
              <button
                id="createRoomBtn"
                class="action-button secondary"
                style="width: 100%; padding: 20px"
              >
                ğŸ¯ åˆ›å»ºæˆ¿é—´<br />
                <small style="font-size: 12px; opacity: 0.8"
                  >ç”Ÿæˆæˆ¿é—´å·å¹¶ç­‰å¾…æœ‹å‹</small
                >
              </button>
            </div>
            <div style="flex: 1">
              <button
                id="joinRoomBtn"
                class="action-button primary"
                style="width: 100%; padding: 20px"
              >
                ğŸ”— åŠ å…¥æˆ¿é—´<br />
                <small style="font-size: 12px; opacity: 0.8"
                  >è¾“å…¥æœ‹å‹çš„æˆ¿é—´å·</small
                >
              </button>
            </div>
          </div>

          <!-- åŠ å…¥æˆ¿é—´çš„è¾“å…¥åŒºåŸŸ -->
          <div id="joinRoomSection" style="display: none">
            <input
              id="roomIdInput"
              type="text"
              class="code-area"
              placeholder="è¾“å…¥æœ‹å‹çš„æˆ¿é—´å·ï¼Œå¦‚ï¼šABC123"
              maxlength="6"
              style="
                text-transform: uppercase;
                text-align: center;
                font-size: 18px;
                letter-spacing: 3px;
                margin-bottom: 15px;
              "
            />
            <button
              id="joinRoom"
              class="action-button primary"
              style="width: 100%"
            >
              ğŸš€ åŠ å…¥æˆ¿é—´
            </button>
          </div>

          <div id="roomStatus" class="step-hint" style="display: none">
            <p id="roomStatusText">ğŸ”„ æ­£åœ¨è¿æ¥æˆ¿é—´...</p>
          </div>
        </div>
      </div>

      <!-- ç®€åŒ–çš„è¿æ¥è¿›åº¦æŒ‡ç¤ºå™¨ -->
      <div id="connectionProgress" class="connection-progress">
        <h4 style="margin: 0 0 15px 0; color: #333">ğŸ”„ æ­£åœ¨è¿æ¥</h4>
        <div class="progress-dots">
          <div id="dot1" class="progress-dot"></div>
          <div id="dot2" class="progress-dot"></div>
          <div id="dot3" class="progress-dot"></div>
          <div id="dot4" class="progress-dot"></div>
        </div>
        <div id="progressMessage" class="progress-message">å»ºç«‹è¿æ¥ä¸­...</div>
      </div>

      <!-- ç®€åŒ–çŠ¶æ€æŒ‡ç¤ºå™¨ -->
      <div
        id="status"
        class="status"
        style="background: #f8f9fa; color: #666; display: none"
      ></div>

      <!-- èŠå¤©ç•Œé¢ -->
      <div id="chatInterface" class="chat-interface">
        <div id="messages"></div>

        <!-- è¾“å…¥åŒºåŸŸ -->
        <div class="input-area">
          <div class="input-container">
            <!-- å›¾ç‰‡é¢„è§ˆåŒºåŸŸ -->
            <div id="imagePreview" style="display: none; margin-bottom: 10px">
              <div
                style="
                  background: #f8f9fa;
                  border-radius: 8px;
                  padding: 10px;
                  border: 1px solid #dee2e6;
                "
              >
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 8px;
                  "
                >
                  <span style="font-size: 12px; color: #666">ğŸ“· å›¾ç‰‡é¢„è§ˆ</span>
                  <button
                    id="cancelImage"
                    style="
                      background: none;
                      border: none;
                      color: #dc3545;
                      cursor: pointer;
                      font-size: 16px;
                    "
                  >
                    âœ•
                  </button>
                </div>
                <img
                  id="previewImg"
                  style="
                    max-width: 200px;
                    max-height: 150px;
                    border-radius: 6px;
                    display: block;
                  "
                />
                <div
                  id="imageInfo"
                  style="font-size: 11px; color: #888; margin-top: 5px"
                ></div>
              </div>
            </div>

            <div class="input-row">
              <input
                id="messageInput"
                placeholder="è¾“å…¥æ¶ˆæ¯æˆ–ç²˜è´´å›¾ç‰‡..."
                disabled
                style="
                  flex: 1;
                  padding: 12px;
                  border: 2px solid #ddd;
                  border-radius: 8px;
                  font-size: 14px;
                  min-height: 20px;
                  resize: none;
                  outline: none;
                "
              />
              <!-- å›¾ç‰‡é€‰æ‹©æŒ‰é’® -->
              <button
                id="imageBtn"
                disabled
                title="é€‰æ‹©å›¾ç‰‡"
                style="
                  background-color: #6c757d;
                  color: white;
                  padding: 12px;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  font-size: 16px;
                  min-width: 48px;
                  height: 48px;
                "
              >
                ğŸ“·
              </button>
              <!-- å‘é€æŒ‰é’® -->
              <button
                id="send"
                disabled
                style="
                  background-color: #28a745;
                  color: white;
                  padding: 12px 20px;
                  border: none;
                  border-radius: 8px;
                  font-weight: bold;
                  min-width: 80px;
                  cursor: pointer;
                  height: 48px;
                "
              >
                ğŸ“¤ å‘é€
              </button>
            </div>
          </div>
        </div>

        <!-- éšè—çš„æ–‡ä»¶è¾“å…¥ -->
        <input
          type="file"
          id="fileInput"
          accept="image/*"
          style="display: none"
        />
      </div>
    </div>

    <script>
      const elements = {
        status: document.getElementById("status"),
        messageInput: document.getElementById("messageInput"),
        send: document.getElementById("send"),
        messages: document.getElementById("messages"),
        // UIæ§åˆ¶å…ƒç´ 
        container: document.querySelector(".container"),
        mainTitle: document.getElementById("mainTitle"),
        simplifiedHeader: document.getElementById("simplifiedHeader"),
        connectionStep: document.getElementById("connectionStep"),
        connectionProgress: document.getElementById("connectionProgress"),
        chatInterface: document.getElementById("chatInterface"),
        // å›¾ç‰‡ç›¸å…³å…ƒç´ 
        imageBtn: document.getElementById("imageBtn"),
        fileInput: document.getElementById("fileInput"),
        imagePreview: document.getElementById("imagePreview"),
        previewImg: document.getElementById("previewImg"),
        imageInfo: document.getElementById("imageInfo"),
        cancelImage: document.getElementById("cancelImage"),
        // æˆ¿é—´ç›¸å…³å…ƒç´ 
        roomIdInput: document.getElementById("roomIdInput"),
        joinRoom: document.getElementById("joinRoom"),
        roomStatus: document.getElementById("roomStatus"),
        roomStatusText: document.getElementById("roomStatusText"),
        chatTitle: document.getElementById("chatTitle"),
        chatSubtitle: document.getElementById("chatSubtitle"),
        // Tokenç›¸å…³å…ƒç´ 
        githubToken: document.getElementById("githubToken"),
        githubTokenRequired: document.getElementById("githubTokenRequired"),
        saveToken: document.getElementById("saveToken"),
        tokenRequiredSection: document.getElementById("tokenRequiredSection"),
        roomMainSection: document.getElementById("roomMainSection"),
        // æ–°çš„æˆ¿é—´é€‰æ‹©å…ƒç´ 
        createRoomBtn: document.getElementById("createRoomBtn"),
        joinRoomBtn: document.getElementById("joinRoomBtn"),
        joinRoomSection: document.getElementById("joinRoomSection"),
      };

      let pc,
        channel,
        currentImage = null, // å½“å‰é€‰æ‹©çš„å›¾ç‰‡æ•°æ®
        isTransferring = false, // æ˜¯å¦æ­£åœ¨ä¼ è¾“
        transferCancelled = false, // ä¼ è¾“æ˜¯å¦è¢«å–æ¶ˆ
        currentRoomId = null, // å½“å‰æˆ¿é—´ID
        roomGistId = null; // æˆ¿é—´å¯¹åº”çš„Gist ID

      // Toast æç¤ºå‡½æ•°
      function showToast(message, type = "success") {
        // ç§»é™¤ç°æœ‰çš„toast
        const existingToast = document.querySelector(".toast");
        if (existingToast) {
          existingToast.remove();
        }

        // åˆ›å»ºæ–°çš„toast
        const toast = document.createElement("div");
        toast.className = `toast ${type}`;

        const icon = type === "success" ? "âœ…" : "âŒ";
        toast.innerHTML = `<span>${icon}</span><span>${message}</span>`;

        document.body.appendChild(toast);

        // æ˜¾ç¤ºtoast
        setTimeout(() => {
          toast.classList.add("show");
        }, 100);

        // 3ç§’åéšè—
        setTimeout(() => {
          toast.classList.remove("show");
          setTimeout(() => {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
            }
          }, 300);
        }, 3000);
      }

      // ===== GitHub Token ç®¡ç† =====

      // è·å–GitHub Token
      function getGitHubToken() {
        // ä¼˜å…ˆä½¿ç”¨è¾“å…¥æ¡†ä¸­çš„tokenï¼ˆæ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼‰
        if (elements.githubToken && elements.githubToken.value) {
          const inputToken = elements.githubToken.value.trim();
          if (inputToken) {
            // ä¿å­˜åˆ°localStorage
            localStorage.setItem("githubToken", inputToken);
            return inputToken;
          }
        }

        // ä»localStorageè·å–ä¿å­˜çš„token
        return localStorage.getItem("githubToken") || null;
      }

      // æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆçš„token
      function hasValidToken() {
        const token = getGitHubToken();
        return token && token.length > 10; // ç®€å•éªŒè¯tokenæ ¼å¼
      }

      // æ¸…é™¤token
      function clearGitHubToken() {
        localStorage.removeItem("githubToken");
        elements.githubToken.value = "";
      }

      // ===== çº¯Gistæ–¹æ¡ˆï¼šåˆ›å»ºç‹¬ç«‹çš„offerå’Œanswer Gist =====

      // åˆ›å»ºæˆ¿é—´Gistçš„åŒ…è£…å‡½æ•°
      async function createRoomGist(roomId, roomData) {
        try {
          const headers = {
            "Content-Type": "application/json",
          };

          const token = getGitHubToken();
          if (token) {
            headers["Authorization"] = `Bearer ${token}`;
          }

          const response = await fetch("https://api.github.com/gists", {
            method: "POST",
            headers: headers,
            body: JSON.stringify({
              description: `Chat Room: ${roomId}`,
              public: true, // æ”¹ä¸ºå…¬å¼€ï¼Œä¾¿äºæœç´¢
              files: {
                [`room_${roomId}.json`]: {
                  content: JSON.stringify(roomData),
                },
              },
            }),
          });

          if (!response.ok) {
            if (response.status === 401) {
              const errorMsg = token
                ? "GitHub Tokenæ— æ•ˆï¼Œè¯·æ£€æŸ¥tokenæƒé™æˆ–é‡æ–°ç”Ÿæˆ"
                : "éœ€è¦GitHub Tokenæ‰èƒ½åˆ›å»ºæˆ¿é—´ï¼Œè¯·åœ¨é«˜çº§é€‰é¡¹ä¸­é…ç½®";
              throw new Error(errorMsg);
            }
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const gist = await response.json();
          const gistId = gist.id;

          // ä¿å­˜åˆ°å…¨å±€æˆ¿é—´åˆ—è¡¨ä¸­
          await addToRoomRegistry(roomId, gistId);

          return gistId;
        } catch (error) {
          console.error("åˆ›å»ºæˆ¿é—´Gistå¤±è´¥:", error);
          throw error;
        }
      }

      // è¯»å–æˆ¿é—´Gistçš„åŒ…è£…å‡½æ•°
      async function readRoomGist(gistId) {
        try {
          const headers = {};
          const token = getGitHubToken();
          if (token) {
            headers["Authorization"] = `Bearer ${token}`;
          }

          const response = await fetch(
            `https://api.github.com/gists/${gistId}`,
            { headers: headers }
          );

          if (!response.ok) {
            if (response.status === 404) {
              return null;
            }
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const gist = await response.json();
          const fileName = Object.keys(gist.files)[0];
          const content = gist.files[fileName].content;
          return JSON.parse(content);
        } catch (error) {
          console.error("è¯»å–æˆ¿é—´Gistå¤±è´¥:", error);
          throw error;
        }
      }

      // æ·»åŠ åˆ°æˆ¿é—´æ³¨å†Œè¡¨ï¼ˆæ›´æ–°å…¨å±€æ³¨å†Œè¡¨Gistï¼‰
      async function addToRoomRegistry(roomId, gistId) {
        try {
          const GLOBAL_REGISTRY_GIST_ID = "55e80e797800fb3d2efd87782db79bb5";

          console.log(`ğŸ“ å°†æˆ¿é—´ ${roomId} æ·»åŠ åˆ°å…¨å±€æ³¨å†Œè¡¨...`);

          // è¯»å–å½“å‰æ³¨å†Œè¡¨
          let registry;
          try {
            registry = await readRoomGist(GLOBAL_REGISTRY_GIST_ID);
          } catch (error) {
            console.log("æ³¨å†Œè¡¨ä¸å­˜åœ¨æˆ–ä¸ºç©ºï¼Œåˆ›å»ºæ–°çš„æ³¨å†Œè¡¨");
            registry = { rooms: {} };
          }

          if (!registry.rooms) {
            registry.rooms = {};
          }

          // æ·»åŠ æ–°æˆ¿é—´
          registry.rooms[roomId] = {
            gistId: gistId,
            created: Date.now(),
          };

          // æ›´æ–°æ³¨å†Œè¡¨Gistï¼ˆåˆ›å»ºæ–°ç‰ˆæœ¬ï¼Œå› ä¸ºæ— æ³•ç›´æ¥æ›´æ–°ï¼‰
          const updatedRegistryGistId = await createRoomGist(
            "Global Room Registry",
            { rooms: registry.rooms }
          );

          console.log(
            `ğŸ“ æˆ¿é—´ ${roomId} å·²æ·»åŠ åˆ°æ³¨å†Œè¡¨ï¼Œæ–°æ³¨å†Œè¡¨ID: ${updatedRegistryGistId}`
          );

          // è¿™é‡Œæœ‰ä¸ªé—®é¢˜ï¼šæˆ‘ä»¬æ— æ³•è®©æ‰€æœ‰äººéƒ½çŸ¥é“æ–°çš„æ³¨å†Œè¡¨ID
          // æ‰€ä»¥è¿™ä¸ªæ–¹æ¡ˆè¿˜æ˜¯æœ‰ç¼ºé™·çš„...
        } catch (error) {
          console.warn("æ·»åŠ åˆ°æ³¨å†Œè¡¨å¤±è´¥:", error);
        }
      }

      // ç”Ÿæˆæˆ¿é—´ç 
      function generateRoomId() {
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        let result = "";
        for (let i = 0; i < 6; i++) {
          result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
      }

      // æŸ¥æ‰¾æˆ¿é—´çš„Gist IDï¼ˆä»localStorageç¼“å­˜ä¸­æŸ¥æ‰¾ï¼‰
      function getRoomGistId(roomId) {
        const roomCache = JSON.parse(localStorage.getItem("roomCache") || "{}");
        return roomCache[roomId] || null;
      }

      // ä¿å­˜æˆ¿é—´çš„Gist IDåˆ°ç¼“å­˜
      function saveRoomGistId(roomId, gistId) {
        const roomCache = JSON.parse(localStorage.getItem("roomCache") || "{}");
        roomCache[roomId] = gistId;
        localStorage.setItem("roomCache", JSON.stringify(roomCache));
      }

      // æ¸…é™¤ç‰¹å®šæˆ¿é—´çš„ç¼“å­˜
      function clearRoomCache(roomId) {
        const roomCache = JSON.parse(localStorage.getItem("roomCache") || "{}");
        delete roomCache[roomId];
        localStorage.setItem("roomCache", JSON.stringify(roomCache));
      }

      // UIçŠ¶æ€ç®¡ç†
      const UIState = {
        INITIAL: "connecting-phase",
        CONNECTING: "connecting-phase",
        CONNECTED: "connected-phase",
      };

      let currentUIState = UIState.INITIAL;

      // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–tokenå’Œç•Œé¢
      function initializeToken() {
        const savedToken = localStorage.getItem("githubToken");

        if (savedToken && savedToken.length > 10) {
          // æœ‰æœ‰æ•ˆTokenï¼Œæ˜¾ç¤ºä¸»ç•Œé¢
          console.log("âœ… æ‰¾åˆ°æœ‰æ•ˆTokenï¼Œæ˜¾ç¤ºä¸»ç•Œé¢");
          showMainInterface();

          if (elements.githubToken) {
            elements.githubToken.value = savedToken;
          }
          if (elements.githubTokenRequired) {
            elements.githubTokenRequired.value = savedToken;
          }
        } else {
          // æ²¡æœ‰Tokenï¼Œæ˜¾ç¤ºTokenè¾“å…¥ç•Œé¢
          console.log("âŒ æœªæ‰¾åˆ°Tokenï¼Œæ˜¾ç¤ºTokenè¾“å…¥ç•Œé¢");
          showTokenRequiredInterface();
        }
      }

      // æ˜¾ç¤ºTokenå¿…å¡«ç•Œé¢
      function showTokenRequiredInterface() {
        elements.tokenRequiredSection.style.display = "block";
        elements.roomMainSection.style.display = "none";

        setTimeout(() => {
          if (elements.githubTokenRequired) {
            elements.githubTokenRequired.focus();
          }
        }, 500);
      }

      // æ˜¾ç¤ºä¸»ç•Œé¢
      function showMainInterface() {
        elements.tokenRequiredSection.style.display = "none";
        elements.roomMainSection.style.display = "block";
      }

      // åˆ‡æ¢UIçŠ¶æ€
      function setUIState(state) {
        currentUIState = state;
        elements.container.className = `container ${state}`;

        switch (state) {
          case UIState.CONNECTED:
            // è¿æ¥æˆåŠŸåçš„UIå˜åŒ–
            elements.mainTitle.style.display = "none";
            elements.simplifiedHeader.style.display = "block";
            elements.connectionStep.style.display = "none";
            elements.connectionProgress.classList.remove("active");
            elements.status.style.display = "none";

            // æ›´æ–°æ ‡é¢˜æ˜¾ç¤ºæˆ¿é—´ä¿¡æ¯
            if (currentRoomId) {
              elements.chatTitle.textContent = `ğŸ  æˆ¿é—´: ${currentRoomId}`;
              elements.chatSubtitle.textContent =
                "ğŸ‰ è¿æ¥æˆåŠŸï¼ä¸æœ‹å‹åœ¨åŒä¸€æˆ¿é—´èŠå¤©";
            }
            break;
          default:
            // è¿æ¥å‰çš„UIçŠ¶æ€
            elements.mainTitle.style.display = "block";
            elements.simplifiedHeader.style.display = "none";
            elements.connectionStep.style.display = "block";
            elements.status.style.display = "block";
        }
      }

      // æ›´æ–°è¿æ¥è¿›åº¦
      function updateProgress(stepNumber, status = "active") {
        // æ›´æ–°è¿›åº¦ç‚¹
        const dots = [
          document.getElementById("dot1"),
          document.getElementById("dot2"),
          document.getElementById("dot3"),
          document.getElementById("dot4"),
        ];

        const messages = [
          "ç”Ÿæˆè¿æ¥ç ...",
          "å»ºç«‹é€šé“...",
          "å®‰å…¨éªŒè¯...",
          "å¯åŠ¨èŠå¤©...",
        ];

        // é‡ç½®æ‰€æœ‰ç‚¹
        dots.forEach((dot, index) => {
          dot.className = "progress-dot";
          if (index < stepNumber - 1) {
            dot.classList.add("completed");
          } else if (index === stepNumber - 1) {
            dot.classList.add(status);
          }
        });

        // æ›´æ–°è¿›åº¦æ¶ˆæ¯
        const progressMessage = document.getElementById("progressMessage");
        if (
          progressMessage &&
          stepNumber > 0 &&
          stepNumber <= messages.length
        ) {
          if (status === "completed" && stepNumber === 4) {
            progressMessage.textContent = "è¿æ¥æˆåŠŸï¼";
          } else {
            progressMessage.textContent = messages[stepNumber - 1];
          }
        }

        // æ˜¾ç¤ºè¿›åº¦æŒ‡ç¤ºå™¨
        if (stepNumber > 0 && stepNumber < 5) {
          elements.connectionProgress.classList.add("active");
        }
      }

      // æ›´æ–°çŠ¶æ€ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
      function setStatus(text, color = "#666") {
        // åªåœ¨å¿…è¦æ—¶æ˜¾ç¤ºçŠ¶æ€
        if (text && text !== "ç­‰å¾…è¿æ¥...") {
          elements.status.textContent = text;
          elements.status.style.color = color;
          elements.status.style.display = "block";
        } else {
          elements.status.style.display = "none";
        }
      }

      // å›¾ç‰‡å¤„ç†å‡½æ•°
      function compressImage(
        file,
        maxWidth = 800,
        maxHeight = 600,
        quality = 0.8
      ) {
        return new Promise((resolve) => {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          const img = new Image();

          img.onload = () => {
            // è®¡ç®—å‹ç¼©åçš„å°ºå¯¸
            let { width, height } = img;
            const ratio = Math.min(maxWidth / width, maxHeight / height);

            if (ratio < 1) {
              width *= ratio;
              height *= ratio;
            }

            canvas.width = width;
            canvas.height = height;

            // ç»˜åˆ¶å¹¶å‹ç¼©
            ctx.drawImage(img, 0, 0, width, height);
            canvas.toBlob(resolve, "image/jpeg", quality);
          };

          img.src = URL.createObjectURL(file);
        });
      }

      // å¤„ç†å›¾ç‰‡æ–‡ä»¶
      async function handleImageFile(file) {
        if (!file.type.startsWith("image/")) {
          alert("è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼");
          return;
        }

        try {
          // å‹ç¼©å›¾ç‰‡
          const compressedFile = await compressImage(file);

          // è½¬æ¢ä¸ºBase64
          const reader = new FileReader();
          reader.onload = (e) => {
            currentImage = {
              data: e.target.result,
              name: file.name,
              size: compressedFile.size,
              type: compressedFile.type,
            };

            // æ˜¾ç¤ºé¢„è§ˆ
            showImagePreview(currentImage);
          };
          reader.readAsDataURL(compressedFile);
        } catch (error) {
          console.error("å›¾ç‰‡å¤„ç†å¤±è´¥:", error);
          alert("å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•ï¼");
        }
      }

      // æ˜¾ç¤ºå›¾ç‰‡é¢„è§ˆ
      function showImagePreview(imageData) {
        elements.previewImg.src = imageData.data;
        elements.imageInfo.textContent = `${imageData.name} (${(
          imageData.size / 1024
        ).toFixed(1)}KB)`;
        elements.imagePreview.style.display = "block";
      }

      // éšè—å›¾ç‰‡é¢„è§ˆ
      function hideImagePreview() {
        elements.imagePreview.style.display = "none";
        currentImage = null;
        elements.fileInput.value = "";
      }

      // å¤„ç†ç²˜è´´äº‹ä»¶
      function handlePaste(e) {
        const items = e.clipboardData?.items;
        if (!items) return;

        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (item.type.startsWith("image/")) {
            e.preventDefault();
            const file = item.getAsFile();
            if (file) {
              handleImageFile(file);
            }
            break;
          }
        }
      }

      // æ˜¾ç¤ºä¼ è¾“è¿›åº¦æ¡
      function showTransferProgress(fileName, fileSize) {
        // åˆ›å»ºè¿›åº¦æ¡è¦†ç›–å±‚
        const overlay = document.createElement("div");
        overlay.className = "progress-overlay";
        overlay.id = "progressOverlay";

        overlay.innerHTML = `
          <div class="progress-container">
            <h3 class="progress-title">ğŸ“¤ å‘é€å›¾ç‰‡</h3>
            <div class="progress-text">æ­£åœ¨å‘é€: ${fileName}</div>
            <div class="progress-bar-container">
              <div class="progress-bar" id="progressBar"></div>
            </div>
            <div id="progressText" class="progress-text">0%</div>
            <div class="progress-details">
              <div>æ–‡ä»¶å¤§å°: ${formatFileSize(fileSize)}</div>
              <div id="transferSpeed">ä¼ è¾“é€Ÿåº¦: è®¡ç®—ä¸­...</div>
              <div id="remainingTime">å‰©ä½™æ—¶é—´: è®¡ç®—ä¸­...</div>
            </div>
            <button class="cancel-transfer-btn" onclick="cancelTransfer()">å–æ¶ˆä¼ è¾“</button>
          </div>
        `;

        document.body.appendChild(overlay);
        return overlay;
      }

      // æ›´æ–°ä¼ è¾“è¿›åº¦
      function updateTransferProgress(percentage, speed, remaining) {
        const progressBar = document.getElementById("progressBar");
        const progressText = document.getElementById("progressText");
        const transferSpeed = document.getElementById("transferSpeed");
        const remainingTime = document.getElementById("remainingTime");

        if (progressBar) {
          progressBar.style.width = percentage + "%";
        }
        if (progressText) {
          progressText.textContent = Math.round(percentage) + "%";
        }
        if (transferSpeed && speed) {
          transferSpeed.textContent = `ä¼ è¾“é€Ÿåº¦: ${formatFileSize(speed)}/s`;
        }
        if (remainingTime && remaining) {
          remainingTime.textContent = `å‰©ä½™æ—¶é—´: ${formatTime(remaining)}`;
        }
      }

      // éšè—ä¼ è¾“è¿›åº¦æ¡
      function hideTransferProgress() {
        const overlay = document.getElementById("progressOverlay");
        if (overlay) {
          document.body.removeChild(overlay);
        }
        isTransferring = false;
        transferCancelled = false;
      }

      // å–æ¶ˆä¼ è¾“
      function cancelTransfer() {
        transferCancelled = true;
        hideTransferProgress();
        alert("å›¾ç‰‡ä¼ è¾“å·²å–æ¶ˆ");
      }

      // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
      function formatFileSize(bytes) {
        if (bytes === 0) return "0 B";
        const k = 1024;
        const sizes = ["B", "KB", "MB", "GB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i];
      }

      // æ ¼å¼åŒ–æ—¶é—´
      function formatTime(seconds) {
        if (!seconds || seconds === Infinity) return "æœªçŸ¥";
        if (seconds < 60) return Math.round(seconds) + "ç§’";
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.round(seconds % 60);
        return `${minutes}åˆ†${remainingSeconds}ç§’`;
      }

      // åˆ†å—ä¼ è¾“å›¾ç‰‡æ•°æ®
      async function sendImageInChunks(imageData, chunkSize = 16384) {
        // 16KB chunks
        const data = JSON.stringify(imageData);
        const totalSize = data.length;
        const totalChunks = Math.ceil(totalSize / chunkSize);

        // å‘é€ä¼ è¾“å¼€å§‹ä¿¡å·
        const transferId = Date.now().toString();
        channel.send(
          JSON.stringify({
            type: "transfer_start",
            transferId: transferId,
            totalChunks: totalChunks,
            totalSize: totalSize,
            fileName: imageData.name,
          })
        );

        let transferredBytes = 0;
        const startTime = Date.now();

        for (let i = 0; i < totalChunks; i++) {
          if (transferCancelled) {
            // å‘é€å–æ¶ˆä¿¡å·
            channel.send(
              JSON.stringify({
                type: "transfer_cancel",
                transferId: transferId,
              })
            );
            throw new Error("ä¼ è¾“å·²å–æ¶ˆ");
          }

          const start = i * chunkSize;
          const end = Math.min(start + chunkSize, totalSize);
          const chunk = data.slice(start, end);

          // å‘é€æ•°æ®å—
          channel.send(
            JSON.stringify({
              type: "transfer_chunk",
              transferId: transferId,
              chunkIndex: i,
              data: chunk,
            })
          );

          transferredBytes += chunk.length;
          const percentage = (transferredBytes / totalSize) * 100;

          // è®¡ç®—ä¼ è¾“é€Ÿåº¦å’Œå‰©ä½™æ—¶é—´
          const elapsed = (Date.now() - startTime) / 1000;
          const speed = transferredBytes / elapsed;
          const remaining = (totalSize - transferredBytes) / speed;

          // æ›´æ–°è¿›åº¦
          updateTransferProgress(percentage, speed, remaining);

          // ç»™ç•Œé¢ä¸€ç‚¹æ—¶é—´æ›´æ–°
          await new Promise((resolve) => setTimeout(resolve, 1));
        }

        // å‘é€ä¼ è¾“å®Œæˆä¿¡å·
        channel.send(
          JSON.stringify({
            type: "transfer_complete",
            transferId: transferId,
          })
        );
      }

      // æ¥æ”¶ç«¯ä¼ è¾“çŠ¶æ€ç®¡ç†
      const receivingTransfers = new Map();

      // å¤„ç†ä¼ è¾“å¼€å§‹
      function handleTransferStart(data) {
        receivingTransfers.set(data.transferId, {
          totalChunks: data.totalChunks,
          totalSize: data.totalSize,
          fileName: data.fileName,
          receivedChunks: new Array(data.totalChunks),
          receivedCount: 0,
        });

        // æ˜¾ç¤ºæ¥æ”¶è¿›åº¦æ¡
        showReceiveProgress(data.fileName, data.totalSize);
      }

      // å¤„ç†ä¼ è¾“æ•°æ®å—
      function handleTransferChunk(data) {
        const transfer = receivingTransfers.get(data.transferId);
        if (!transfer) return;

        transfer.receivedChunks[data.chunkIndex] = data.data;
        transfer.receivedCount++;

        const percentage =
          (transfer.receivedCount / transfer.totalChunks) * 100;
        updateReceiveProgress(percentage);
      }

      // å¤„ç†ä¼ è¾“å®Œæˆ
      function handleTransferComplete(data) {
        const transfer = receivingTransfers.get(data.transferId);
        if (!transfer) return;

        // é‡ç»„å®Œæ•´æ•°æ®
        const completeData = transfer.receivedChunks.join("");

        try {
          const imageData = JSON.parse(completeData);
          addMessage(imageData, false);
          hideReceiveProgress();
        } catch (error) {
          console.error("é‡ç»„å›¾ç‰‡æ•°æ®å¤±è´¥:", error);
          alert("æ¥æ”¶å›¾ç‰‡å¤±è´¥");
          hideReceiveProgress();
        }

        receivingTransfers.delete(data.transferId);
      }

      // å¤„ç†ä¼ è¾“å–æ¶ˆ
      function handleTransferCancel(data) {
        receivingTransfers.delete(data.transferId);
        hideReceiveProgress();
        alert("å¯¹æ–¹å–æ¶ˆäº†å›¾ç‰‡ä¼ è¾“");
      }

      // æ˜¾ç¤ºæ¥æ”¶è¿›åº¦æ¡
      function showReceiveProgress(fileName, fileSize) {
        const overlay = document.createElement("div");
        overlay.className = "progress-overlay";
        overlay.id = "receiveProgressOverlay";

        overlay.innerHTML = `
          <div class="progress-container">
            <h3 class="progress-title">ğŸ“¥ æ¥æ”¶å›¾ç‰‡</h3>
            <div class="progress-text">æ­£åœ¨æ¥æ”¶: ${fileName}</div>
            <div class="progress-bar-container">
              <div class="progress-bar" id="receiveProgressBar" style="background: linear-gradient(90deg, #28a745, #20c997);"></div>
            </div>
            <div id="receiveProgressText" class="progress-text">0%</div>
            <div class="progress-details">
              <div>æ–‡ä»¶å¤§å°: ${formatFileSize(fileSize)}</div>
            </div>
          </div>
        `;

        document.body.appendChild(overlay);
      }

      // æ›´æ–°æ¥æ”¶è¿›åº¦
      function updateReceiveProgress(percentage) {
        const progressBar = document.getElementById("receiveProgressBar");
        const progressText = document.getElementById("receiveProgressText");

        if (progressBar) {
          progressBar.style.width = percentage + "%";
        }
        if (progressText) {
          progressText.textContent = Math.round(percentage) + "%";
        }
      }

      // éšè—æ¥æ”¶è¿›åº¦æ¡
      function hideReceiveProgress() {
        const overlay = document.getElementById("receiveProgressOverlay");
        if (overlay) {
          document.body.removeChild(overlay);
        }
      }

      // æ˜¾ç¤ºæ¶ˆæ¯
      function addMessage(content, isMe = false) {
        const div = document.createElement("div");
        div.className = `message ${isMe ? "me" : "them"}`;

        // åˆ›å»ºæ¶ˆæ¯å†…å®¹
        const messageContent = document.createElement("div");
        messageContent.style.marginBottom = "4px";

        // æ£€æŸ¥æ˜¯å¦æ˜¯å›¾ç‰‡æ¶ˆæ¯
        if (typeof content === "object" && content.type === "image") {
          // å›¾ç‰‡æ¶ˆæ¯
          const img = document.createElement("img");
          img.src = content.data;
          img.style.maxWidth = "250px";
          img.style.maxHeight = "200px";
          img.style.borderRadius = "8px";
          img.style.cursor = "pointer";
          img.style.display = "block";

          // æ·»åŠ å›¾ç‰‡ä¿¡æ¯
          const imageInfo = document.createElement("div");
          imageInfo.textContent = content.name;
          imageInfo.style.fontSize = "11px";
          imageInfo.style.opacity = "0.8";
          imageInfo.style.marginTop = "4px";

          // ç‚¹å‡»æ”¾å¤§å›¾ç‰‡
          img.onclick = () => {
            const modal = document.createElement("div");
            modal.style.cssText = `
              position: fixed; top: 0; left: 0; width: 100%; height: 100%;
              background: rgba(0,0,0,0.8); display: flex; align-items: center;
              justify-content: center; z-index: 1000; cursor: pointer;
            `;

            const fullImg = document.createElement("img");
            fullImg.src = content.data;
            fullImg.style.cssText = `
              max-width: 90%; max-height: 90%; border-radius: 8px;
              box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            `;

            modal.appendChild(fullImg);
            document.body.appendChild(modal);

            modal.onclick = () => document.body.removeChild(modal);
          };

          messageContent.appendChild(img);
          messageContent.appendChild(imageInfo);
        } else {
          // æ–‡æœ¬æ¶ˆæ¯
          messageContent.textContent = content;
        }

        // åˆ›å»ºæ—¶é—´æˆ³
        const timestamp = document.createElement("div");
        const now = new Date();
        timestamp.textContent = now.toLocaleTimeString("zh-CN", {
          hour: "2-digit",
          minute: "2-digit",
        });
        timestamp.style.fontSize = "10px";
        timestamp.style.opacity = "0.7";
        timestamp.style.textAlign = isMe ? "right" : "left";

        div.appendChild(messageContent);
        div.appendChild(timestamp);
        elements.messages.appendChild(div);

        // å¹³æ»‘æ»šåŠ¨åˆ°åº•éƒ¨
        elements.messages.scrollTo({
          top: elements.messages.scrollHeight,
          behavior: "smooth",
        });
      }

      // åˆ›å»ºè¿æ¥
      function createConnection() {
        // ä½¿ç”¨æ›´ç¨³å®šçš„ICEæœåŠ¡å™¨é…ç½®
        pc = new RTCPeerConnection({
          iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" },
          ],
          iceCandidatePoolSize: 10,
        });

        pc.onicecandidate = (e) => {
          if (!e.candidate) {
            // æ›´æ–°è¿›åº¦ï¼šç”Ÿæˆè¿æ¥ä¿¡æ¯å®Œæˆ
            updateProgress(1, "completed");
            updateProgress(2, "active");

            // æˆ¿é—´æ¨¡å¼ä¸‹ä¸éœ€è¦ç”Ÿæˆä¼ ç»Ÿè¿æ¥ç 
            console.log("æˆ¿é—´æ¨¡å¼ï¼šæ— éœ€ç”Ÿæˆä¼ ç»Ÿè¿æ¥ç ");

            // æˆ¿é—´æ¨¡å¼ä¸‹ä¸éœ€è¦ä¼ ç»Ÿè¿æ¥ç é€»è¾‘
            console.log("æˆ¿é—´æ¨¡å¼ï¼šICE gatheringå®Œæˆ");
          }
        };

        // ç»Ÿä¸€çš„è¿æ¥çŠ¶æ€ç®¡ç†
        let connectionStateTimeout;

        pc.onconnectionstatechange = () => {
          // æ¸…é™¤ä¹‹å‰çš„è¶…æ—¶ï¼Œé¿å…çŠ¶æ€å†²çª
          clearTimeout(connectionStateTimeout);

          console.log("è¿æ¥çŠ¶æ€:", pc.connectionState);

          switch (pc.connectionState) {
            case "connecting":
              updateProgress(3, "active");
              break;
            case "connected":
              // å®Œæˆæ‰€æœ‰æ­¥éª¤
              updateProgress(4, "completed");
              console.log("ğŸ‰ è¿æ¥æˆåŠŸï¼");

              // å»¶è¿Ÿåˆ‡æ¢åˆ°èŠå¤©ç•Œé¢
              connectionStateTimeout = setTimeout(() => {
                setUIState(UIState.CONNECTED);
              }, 1500);
              break;
            case "disconnected":
              setStatus("è¿æ¥å·²æ–­å¼€", "#dc3545");
              elements.connectionProgress.classList.remove("active");
              break;
            case "failed":
              setStatus("è¿æ¥å¤±è´¥ï¼Œè¯·é‡è¯•", "#dc3545");
              elements.connectionProgress.classList.remove("active");
              console.error("è¿æ¥å¤±è´¥");

              // å»¶è¿Ÿæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯ï¼Œé¿å…ç«‹å³å¼¹å‡º
              connectionStateTimeout = setTimeout(() => {
                alert("è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–é‡æ–°ç”Ÿæˆè¿æ¥ç ");
              }, 1000);
              break;
          }
        };

        // ç®€åŒ–çš„ICEçŠ¶æ€ç›‘æ§
        pc.oniceconnectionstatechange = () => {
          // åªåœ¨å…³é”®çŠ¶æ€å˜åŒ–æ—¶è®°å½•
          if (
            pc.iceConnectionState === "failed" ||
            pc.iceConnectionState === "disconnected"
          ) {
            console.log("ICEçŠ¶æ€:", pc.iceConnectionState);
          }
        };

        pc.ondatachannel = (e) => {
          channel = e.channel;
          setupChannel();
        };

        return pc;
      }

      // è®¾ç½®æ•°æ®é€šé“
      function setupChannel() {
        channel.onopen = () => {
          elements.messageInput.disabled = false;
          elements.send.disabled = false;
          elements.imageBtn.disabled = false;

          // å¦‚æœè¿˜æ²¡æœ‰åˆ‡æ¢åˆ°è¿æ¥çŠ¶æ€ï¼Œè¿™é‡Œå†æ¬¡ç¡®ä¿åˆ‡æ¢
          if (currentUIState !== UIState.CONNECTED) {
            updateProgress(4, "completed");
            setTimeout(() => {
              setUIState(UIState.CONNECTED);
            }, 500);
          }
        };

        channel.onmessage = (e) => {
          try {
            // å°è¯•è§£æJSONï¼Œçœ‹æ˜¯å¦æ˜¯ä¼ è¾“ç›¸å…³æ¶ˆæ¯
            const data = JSON.parse(e.data);

            // å¤„ç†åˆ†å—ä¼ è¾“æ¶ˆæ¯
            if (data.type === "transfer_start") {
              handleTransferStart(data);
            } else if (data.type === "transfer_chunk") {
              handleTransferChunk(data);
            } else if (data.type === "transfer_complete") {
              handleTransferComplete(data);
            } else if (data.type === "transfer_cancel") {
              handleTransferCancel(data);
            } else if (data.type === "image") {
              addMessage(data, false);
            } else {
              addMessage(data.text || e.data, false);
            }
          } catch (err) {
            // å¦‚æœè§£æå¤±è´¥ï¼Œå½“ä½œæ™®é€šæ–‡æœ¬æ¶ˆæ¯
            addMessage(e.data, false);
          }
        };

        channel.onclose = () => {
          elements.messageInput.disabled = true;
          elements.send.disabled = true;
          elements.imageBtn.disabled = true;
          setStatus("è¿æ¥å·²æ–­å¼€", "#dc3545");
        };

        channel.onerror = (error) => {
          console.error("æ•°æ®é€šé“é”™è¯¯:", error);
          setStatus("é€šé“é”™è¯¯", "#dc3545");
        };
      }

      // å‘é€æ¶ˆæ¯
      async function sendMessage() {
        const text = elements.messageInput.value.trim();

        if (!channel || channel.readyState !== "open") {
          alert("è¿æ¥å°šæœªå»ºç«‹ï¼Œæ— æ³•å‘é€æ¶ˆæ¯");
          return;
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡è¦å‘é€
        if (currentImage) {
          if (isTransferring) {
            alert("æ­£åœ¨ä¼ è¾“å›¾ç‰‡ï¼Œè¯·ç¨å€™...");
            return;
          }

          try {
            isTransferring = true;

            // æ„å»ºå›¾ç‰‡æ¶ˆæ¯
            const imageMessage = {
              type: "image",
              data: currentImage.data,
              name: currentImage.name,
              size: currentImage.size,
            };

            // å¦‚æœæœ‰æ–‡æœ¬ï¼Œæ·»åŠ è¯´æ˜
            if (text) {
              imageMessage.caption = text;
            }

            // æ˜¾ç¤ºè¿›åº¦æ¡
            showTransferProgress(currentImage.name, currentImage.size);

            // ä½¿ç”¨åˆ†å—ä¼ è¾“å‘é€å›¾ç‰‡
            await sendImageInChunks(imageMessage);

            // ä¼ è¾“æˆåŠŸï¼Œæ˜¾ç¤ºè‡ªå·±å‘é€çš„æ¶ˆæ¯
            const displayMessage = { ...imageMessage };
            if (text) {
              // å¦‚æœæœ‰è¯´æ˜æ–‡å­—ï¼Œå…ˆæ˜¾ç¤ºå›¾ç‰‡å†æ˜¾ç¤ºæ–‡å­—
              addMessage(displayMessage, true);
              addMessage(text, true);
            } else {
              addMessage(displayMessage, true);
            }

            // éšè—è¿›åº¦æ¡å¹¶æ¸…ç†
            hideTransferProgress();
            elements.messageInput.value = "";
            hideImagePreview();
          } catch (error) {
            console.error("å‘é€å›¾ç‰‡å¤±è´¥:", error);
            hideTransferProgress();
            if (!transferCancelled) {
              alert("å‘é€å›¾ç‰‡å¤±è´¥: " + error.message);
            }
          }
        } else if (text) {
          try {
            // å‘é€æ–‡æœ¬æ¶ˆæ¯
            channel.send(text);

            // æ˜¾ç¤ºè‡ªå·±å‘é€çš„æ¶ˆæ¯
            addMessage(text, true);
            elements.messageInput.value = "";
          } catch (error) {
            console.error("å‘é€æ¶ˆæ¯å¤±è´¥:", error);
            alert("å‘é€æ¶ˆæ¯å¤±è´¥: " + error.message);
          }
        }
      }

      // ===== æˆ¿é—´è¿æ¥é€»è¾‘ =====

      // è¿æ¥åˆ°æˆ¿é—´
      async function connectToRoom(roomId) {
        if (!roomId || roomId.length !== 6) {
          showToast("è¯·è¾“å…¥6ä½æˆ¿é—´å·", "error");
          return;
        }

        roomId = roomId.toUpperCase();
        currentRoomId = roomId;

        // æ˜¾ç¤ºè¿æ¥çŠ¶æ€
        elements.roomStatus.style.display = "block";
        elements.roomStatusText.textContent = "ğŸ”„ æ­£åœ¨è¿æ¥æˆ¿é—´...";
        elements.joinRoom.disabled = true;

        try {
          // è¶…ç®€å•æ–¹æ¡ˆï¼šç‹¬ç«‹çš„offerå’Œanswer Gist
          console.log(`ğŸ” æ£€æŸ¥æˆ¿é—´: ${roomId}`);

          // 1. æœç´¢æˆ¿é—´çš„offer Gist
          const offerGist = await searchOfferGist(roomId);

          if (offerGist) {
            // æ‰¾åˆ°offerï¼Œä½œä¸ºanswereråˆ›å»ºanswer
            console.log(`âœ… æ‰¾åˆ°æˆ¿é—´ ${roomId} çš„offer`);
            elements.roomStatusText.textContent = "âœ… æ‰¾åˆ°offerï¼Œç”Ÿæˆanswer...";
            await createAnswerAndConnect(roomId, offerGist);
          } else {
            // æ²¡æœ‰offerï¼Œä½œä¸ºoffereråˆ›å»ºoffer
            console.log(`ğŸ—ï¸ æˆ¿é—´ ${roomId} æ²¡æœ‰offerï¼Œåˆ›å»ºofferå¹¶ç­‰å¾…`);
            elements.roomStatusText.textContent = "ğŸ—ï¸ åˆ›å»ºofferå¹¶ç­‰å¾…answer...";
            await createOfferAndWait(roomId);
          }
        } catch (error) {
          console.error("æˆ¿é—´è¿æ¥å¤±è´¥:", error);
          elements.roomStatusText.textContent = "âŒ è¿æ¥å¤±è´¥";
          elements.joinRoom.disabled = false;
          showToast("æˆ¿é—´è¿æ¥å¤±è´¥: " + error.message, "error");
        }
      }

      // æœç´¢offer Gistï¼ˆé€šè¿‡æ–‡ä»¶åæœç´¢ï¼‰
      async function searchOfferGist(roomId) {
        try {
          const headers = {};
          const token = getGitHubToken();
          if (token) {
            headers["Authorization"] = `Bearer ${token}`;
          }

          // æ­£ç¡®æ–¹æ³•ï¼šè·å–å…¬å¼€Giståˆ—è¡¨å¹¶ç­›é€‰
          console.log(`ğŸ” æŸ¥æ‰¾æˆ¿é—´ ${roomId} çš„offer Gist`);

          // æ·»åŠ GitHub APIæ¨èçš„headers
          headers["Accept"] = "application/vnd.github+json";
          headers["X-GitHub-Api-Version"] = "2022-11-28";

          const response = await fetch("https://api.github.com/gists/public", {
            headers: headers,
          });

          if (response.ok) {
            const gists = await response.json();
            console.log(`ğŸ“„ è·å–åˆ° ${gists.length} ä¸ªå…¬å¼€Gist`);

            // ç­›é€‰åŒ…å«æˆ‘ä»¬æˆ¿é—´offerçš„Gist
            for (const gist of gists) {
              // æ£€æŸ¥æè¿°
              if (
                gist.description &&
                gist.description.includes(`Room ${roomId} Offer`)
              ) {
                console.log(`âœ… é€šè¿‡æè¿°æ‰¾åˆ°offer Gist: ${gist.id}`);
                return { id: gist.id };
              }

              // æ£€æŸ¥æ–‡ä»¶å
              const files = Object.keys(gist.files);
              if (files.includes(`offer_${roomId}.json`)) {
                console.log(`âœ… é€šè¿‡æ–‡ä»¶åæ‰¾åˆ°offer Gist: ${gist.id}`);
                return { id: gist.id };
              }
            }
          }

          console.log(`âŒ æœªæ‰¾åˆ°æˆ¿é—´ ${roomId} çš„offer`);
          return null;
        } catch (error) {
          console.error("æœç´¢offerå¤±è´¥:", error);
          return null;
        }
      }

      // åˆ›å»ºofferå¹¶ç­‰å¾…answer
      async function createOfferAndWait(roomId) {
        try {
          // 1. åˆ›å»ºWebRTC offer
          updateProgress(1, "active");
          pc = createConnection();
          channel = pc.createDataChannel("chat");
          setupChannel();

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) resolve();
            };
          });

          const offerTimestamp = Date.now();

          // 2. åˆ›å»ºofferæ•°æ®
          const offerData = {
            roomId: roomId,
            offer: pc.localDescription,
            timestamp: offerTimestamp,
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          // 3. åˆ›å»ºoffer Gist
          const offerGistId = await createRoomGist(
            `Room ${roomId} Offer`,
            offerData,
            `offer_${roomId}.json`
          );

          console.log(`âœ… Offerå·²åˆ›å»º: ${offerGistId}`);
          elements.roomStatusText.textContent = "â³ ç­‰å¾…å…¶ä»–äººåŠ å…¥...";

          // 4. å¼€å§‹è½®è¯¢æœç´¢answer
          pollForAnswer(roomId, offerTimestamp);
        } catch (error) {
          console.error("åˆ›å»ºofferå¤±è´¥:", error);
          throw error;
        }
      }

      // åˆ›å»ºanswerå¹¶è¿æ¥
      async function createAnswerAndConnect(roomId, offerGist) {
        try {
          // 1. è¯»å–offeræ•°æ®
          const offerData = await readRoomGist(offerGist.id);
          console.log("Offeræ•°æ®:", offerData);

          // 2. åˆ›å»ºWebRTCè¿æ¥
          updateProgress(1, "active");
          pc = createConnection();

          await pc.setRemoteDescription(
            new RTCSessionDescription(offerData.offer)
          );
          updateProgress(2, "active");

          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);

          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) resolve();
            };
          });

          // 3. åˆ›å»ºansweræ•°æ®
          const answerData = {
            roomId: roomId,
            answer: pc.localDescription,
            offerTimestamp: offerData.timestamp,
            timestamp: Date.now(),
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          // 4. åˆ›å»ºanswer Gist
          const answerGistId = await createRoomGist(
            `Room ${roomId} Answer`,
            answerData,
            `answer_${roomId}.json`
          );

          console.log(`âœ… Answerå·²åˆ›å»º: ${answerGistId}`);
          updateProgress(3, "active");
          elements.roomStatusText.textContent = "ğŸ¤ æ­£åœ¨å»ºç«‹è¿æ¥...";
        } catch (error) {
          console.error("åˆ›å»ºanswerå¤±è´¥:", error);
          throw error;
        }
      }

      // è½®è¯¢æœç´¢answer
      function pollForAnswer(roomId, offerTimestamp) {
        let pollCount = 0;
        const maxPolls = 100;

        const pollInterval = setInterval(async () => {
          try {
            pollCount++;
            elements.roomStatusText.textContent = `â³ ç­‰å¾…answer... (${Math.ceil(
              pollCount / 20
            )}åˆ†é’Ÿ)`;

            // æœç´¢answer Gist
            const answerGist = await searchAnswerGist(roomId);

            if (answerGist) {
              clearInterval(pollInterval);

              // è¯»å–answeræ•°æ®
              const answerData = await readRoomGist(answerGist.id);

              if (answerData && answerData.offerTimestamp === offerTimestamp) {
                await pc.setRemoteDescription(
                  new RTCSessionDescription(answerData.answer)
                );
                updateProgress(3, "active");
                elements.roomStatusText.textContent = "ğŸ¤ æ­£åœ¨å»ºç«‹è¿æ¥...";
              }
            }

            if (pollCount >= maxPolls) {
              clearInterval(pollInterval);
              elements.roomStatusText.textContent = "â° ç­‰å¾…è¶…æ—¶ï¼Œè¯·é‡è¯•";
              elements.joinRoom.disabled = false;
            }
          } catch (error) {
            console.error("è½®è¯¢answerå¤±è´¥:", error);
          }
        }, 3000);
      }

      // æœç´¢answer Gist
      async function searchAnswerGist(roomId) {
        try {
          const headers = {};
          const token = getGitHubToken();
          if (token) {
            headers["Authorization"] = `Bearer ${token}`;
          }

          // æ­£ç¡®æ–¹æ³•ï¼šè·å–å…¬å¼€Giståˆ—è¡¨å¹¶ç­›é€‰
          console.log(`ğŸ” æŸ¥æ‰¾æˆ¿é—´ ${roomId} çš„answer Gist`);

          // æ·»åŠ GitHub APIæ¨èçš„headers
          headers["Accept"] = "application/vnd.github+json";
          headers["X-GitHub-Api-Version"] = "2022-11-28";

          const response = await fetch("https://api.github.com/gists/public", {
            headers: headers,
          });

          if (response.ok) {
            const gists = await response.json();
            console.log(`ğŸ“„ æ£€æŸ¥ ${gists.length} ä¸ªå…¬å¼€Gistå¯»æ‰¾answer`);

            // ç­›é€‰åŒ…å«æˆ‘ä»¬æˆ¿é—´answerçš„Gist
            for (const gist of gists) {
              // æ£€æŸ¥æè¿°
              if (
                gist.description &&
                gist.description.includes(`Room ${roomId} Answer`)
              ) {
                console.log(`âœ… é€šè¿‡æè¿°æ‰¾åˆ°answer Gist: ${gist.id}`);
                return { id: gist.id };
              }

              // æ£€æŸ¥æ–‡ä»¶å
              const files = Object.keys(gist.files);
              if (files.includes(`answer_${roomId}.json`)) {
                console.log(`âœ… é€šè¿‡æ–‡ä»¶åæ‰¾åˆ°answer Gist: ${gist.id}`);
                return { id: gist.id };
              }
            }
          }

          console.log(`âŒ æœªæ‰¾åˆ°æˆ¿é—´ ${roomId} çš„answer`);
          return null;
        } catch (error) {
          console.error("æœç´¢answerå¤±è´¥:", error);
          return null;
        }
      }

      // ä¿®æ”¹createRoomGistæ”¯æŒè‡ªå®šä¹‰æ–‡ä»¶å
      async function createRoomGist(description, data, fileName = "data.json") {
        try {
          const headers = {
            Accept: "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
            "Content-Type": "application/json",
          };

          const token = getGitHubToken();
          if (token) {
            headers["Authorization"] = `Bearer ${token}`;
          }

          const response = await fetch("https://api.github.com/gists", {
            method: "POST",
            headers: headers,
            body: JSON.stringify({
              description: description,
              public: true, // å…¬å¼€ä¾¿äºæœç´¢
              files: {
                [fileName]: {
                  content: JSON.stringify(data),
                },
              },
            }),
          });

          if (!response.ok) {
            if (response.status === 401) {
              const errorMsg = token
                ? "GitHub Tokenæ— æ•ˆï¼Œè¯·æ£€æŸ¥tokenæƒé™æˆ–é‡æ–°ç”Ÿæˆ"
                : "éœ€è¦GitHub Tokenæ‰èƒ½åˆ›å»ºæˆ¿é—´ï¼Œè¯·åœ¨é«˜çº§é€‰é¡¹ä¸­é…ç½®";
              throw new Error(errorMsg);
            }
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const gist = await response.json();
          return gist.id;
        } catch (error) {
          console.error("åˆ›å»ºGistå¤±è´¥:", error);

          if (error.message.includes("éœ€è¦GitHub Token")) {
            const details = document.querySelector("#tokenSection details");
            if (details && !details.open) {
              details.open = true;
              showToast("è¯·é…ç½®GitHub Tokenåé‡è¯•", "error");
            }
          }

          throw error;
        }
      }

      // æŸ¥æ‰¾æˆ¿é—´çš„offer Gist
      async function findOfferGist(roomId) {
        try {
          // çº¦å®šï¼šofferçš„Gistæè¿°ä¸º "Room ABC123 Offer"
          // å°è¯•å‡ ä¸ªå¯èƒ½çš„offer Gist IDï¼ˆåŸºäºæ‚¨çš„è´¦å·åˆ›å»ºçš„ï¼‰
          const possibleOfferGists = [
            "55e80e797800fb3d2efd87782db79bb5", // æ‚¨åˆ›å»ºçš„é‚£ä¸ª
            // å¯ä»¥æ·»åŠ æ›´å¤šå¤‡ç”¨çš„
          ];

          for (const gistId of possibleOfferGists) {
            try {
              console.log(`ğŸ” æ£€æŸ¥offer Gist: ${gistId}`);
              const gistData = await readRoomGist(gistId);

              // æ£€æŸ¥æ˜¯å¦åŒ…å«æˆ‘ä»¬æˆ¿é—´çš„offer
              if (
                gistData &&
                gistData.roomId === roomId &&
                gistData.offers &&
                gistData.offers.length > 0
              ) {
                console.log(`âœ… æ‰¾åˆ°æˆ¿é—´ ${roomId} çš„offer`);
                return gistId;
              }
            } catch (error) {
              console.warn(`Gist ${gistId} è¯»å–å¤±è´¥:`, error);
            }
          }

          console.log(`âŒ æœªæ‰¾åˆ°æˆ¿é—´ ${roomId} çš„offer`);
          return null;
        } catch (error) {
          console.error("æŸ¥æ‰¾offerå¤±è´¥:", error);
          return null;
        }
      }

      // ä½œä¸ºoffereråˆ›å»ºæˆ¿é—´
      async function createAsOfferer(roomId) {
        try {
          // åˆ›å»ºWebRTC offer
          updateProgress(1, "active");
          pc = createConnection();
          channel = pc.createDataChannel("chat");
          setupChannel();

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) resolve();
            };
          });

          const offerTimestamp = Date.now();

          // åˆ›å»ºæˆ¿é—´æ•°æ®ï¼ˆä»ç„¶ä½¿ç”¨æ‚¨çš„å›ºå®šGistï¼‰
          const roomData = {
            roomId: roomId,
            offers: [
              {
                offer: pc.localDescription,
                timestamp: offerTimestamp,
                userId: "user_" + Math.random().toString(36).substr(2, 9),
              },
            ],
            answers: [],
            created: Date.now(),
          };

          // ä½†æ˜¯ä¸èƒ½çœŸæ­£æ›´æ–°ï¼Œåªèƒ½åˆ›å»ºæ–°ç‰ˆæœ¬...
          console.log("âš ï¸ å½“å‰é™åˆ¶ï¼šæ— æ³•æ›´æ–°Gistï¼Œæ•°æ®åªèƒ½å­˜åœ¨å†…å­˜ä¸­");

          roomGistId = "55e80e797800fb3d2efd87782db79bb5"; // ä½¿ç”¨å›ºå®šID
          elements.roomStatusText.textContent = "â³ ç­‰å¾…å…¶ä»–äººåŠ å…¥...";

          // ç®€åŒ–çš„è½®è¯¢ï¼šåªæ£€æŸ¥å›ºå®šGist
          pollForAnswerSimple(roomId, offerTimestamp);
        } catch (error) {
          console.error("åˆ›å»ºoffererå¤±è´¥:", error);
          throw error;
        }
      }

      // ä½œä¸ºanswereråŠ å…¥
      async function joinAsAnswerer(roomId, offerGistId) {
        try {
          // è¯»å–offeræ•°æ®
          const roomData = await readRoomGist(offerGistId);
          const offer = roomData.offers[0]; // ä½¿ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨çš„offer

          console.log("ğŸ”— è¿æ¥åˆ°offer:", offer);

          // åˆ›å»ºWebRTCè¿æ¥
          updateProgress(1, "active");
          pc = createConnection();

          await pc.setRemoteDescription(new RTCSessionDescription(offer.offer));

          updateProgress(2, "active");

          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);

          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) resolve();
            };
          });

          console.log("âœ… Answerç”Ÿæˆå®Œæˆï¼Œä½†æ— æ³•ä¿å­˜åˆ°å…±äº«Gist");
          console.log("âš ï¸ å½“å‰é™åˆ¶ï¼šæ— æ³•æ›´æ–°Gistä¿å­˜answer");

          updateProgress(3, "active");
          elements.roomStatusText.textContent = "ğŸ¤ æ­£åœ¨å»ºç«‹è¿æ¥...";
        } catch (error) {
          console.error("ä½œä¸ºanswereråŠ å…¥å¤±è´¥:", error);
          throw error;
        }
      }

      // ç®€åŒ–çš„è½®è¯¢
      function pollForAnswerSimple(roomId, offerTimestamp) {
        console.log("âš ï¸ è½®è¯¢åŠŸèƒ½å—é™ï¼šæ— æ³•çœŸæ­£æ£€æŸ¥answer");
        // å½“å‰å®ç°ä¸‹ï¼Œansweræ— æ³•è¢«ä¿å­˜ï¼Œæ‰€ä»¥è½®è¯¢æ— æ„ä¹‰
      }

      // è¶…ç®€å•æ–¹æ¡ˆï¼šå›ºå®šGist ID + ç›´æ¥è¯»å–
      async function tryReadRoomGist(roomId) {
        try {
          // å…³é”®ï¼šæ‰€æœ‰äººéƒ½ä½¿ç”¨åŒä¸€ä¸ªå›ºå®šçš„Gist ID
          const SHARED_GIST_ID = "55e80e797800fb3d2efd87782db79bb5";

          console.log(`ğŸ“– è¯»å–å›ºå®šå…±äº«Gist: ${SHARED_GIST_ID}`);

          try {
            const sharedData = await readRoomGist(SHARED_GIST_ID);
            console.log("å…±äº«Gistå†…å®¹:", sharedData);

            // æ£€æŸ¥è¿™ä¸ªå…±äº«ç©ºé—´æ˜¯å¦æœ‰æˆ‘ä»¬æˆ¿é—´çš„æ•°æ®
            if (sharedData && sharedData[roomId]) {
              console.log(`âœ… åœ¨å…±äº«Gistä¸­æ‰¾åˆ°æˆ¿é—´ ${roomId}`);
              return SHARED_GIST_ID; // è¿”å›å›ºå®šçš„ID
            } else {
              console.log(`âŒ å…±äº«Gistä¸­æ²¡æœ‰æˆ¿é—´ ${roomId}`);
              return null;
            }
          } catch (error) {
            console.error("è¯»å–å…±äº«Gistå¤±è´¥:", error);
            return null;
          }
        } catch (error) {
          console.error("å°è¯•è¯»å–æˆ¿é—´å¤±è´¥:", error);
          return null;
        }
      }

      // åˆ›å»ºç¬¬ä¸€ä¸ªç”¨æˆ·çš„æˆ¿é—´
      async function createFirstUserRoom(roomId) {
        try {
          // 1. åˆ›å»ºWebRTC offer
          updateProgress(1, "active");
          pc = createConnection();
          channel = pc.createDataChannel("chat");
          setupChannel();

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          // ç­‰å¾…ICE gatheringå®Œæˆ
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          const offerTimestamp = Date.now();

          // 2. åˆ›å»ºæˆ¿é—´æ•°æ®ç»“æ„
          const roomData = {
            offer: pc.localDescription,
            offerTimestamp: offerTimestamp,
            answer: null,
            created: Date.now(),
          };

          // 3. æ›´æ–°å›ºå®šçš„å…±äº«Gist
          const SHARED_GIST_ID = "55e80e797800fb3d2efd87782db79bb5";

          // è¯»å–å½“å‰å…±äº«Gistæ•°æ®
          let sharedData = {};
          try {
            sharedData = (await readRoomGist(SHARED_GIST_ID)) || {};
          } catch (error) {
            console.log("å…±äº«Gistä¸ºç©ºï¼Œåˆå§‹åŒ–æ–°æ•°æ®");
          }

          // æ·»åŠ æˆ¿é—´æ•°æ®
          sharedData[roomId] = roomData;

          // âš ï¸ é—®é¢˜ï¼šæˆ‘ä»¬æ— æ³•ç›´æ¥æ›´æ–°ç°æœ‰çš„Gistï¼ˆéœ€è¦åˆ›å»ºæ–°ç‰ˆæœ¬ï¼‰
          // ä½†æ–°ç‰ˆæœ¬ä¼šæœ‰æ–°çš„IDï¼Œå…¶ä»–ç”¨æˆ·å°±æ‰¾ä¸åˆ°äº†ï¼

          console.log(`ğŸ’¾ éœ€è¦æ›´æ–°å…±äº«Gistï¼Œä½†ä¼šäº§ç”Ÿæ–°ID...`);
          console.log("å½“å‰æ–¹æ¡ˆçš„é™åˆ¶ï¼šæ— æ³•çœŸæ­£æ›´æ–°Gistï¼Œåªèƒ½åˆ›å»ºæ–°ç‰ˆæœ¬");

          // ä¸´æ—¶æ–¹æ¡ˆï¼šå°†æˆ¿é—´æ•°æ®å­˜å‚¨åˆ°æ‚¨çš„å›ºå®šGistä¸­
          // ä½†è¿™éœ€è¦æ‚¨çš„GitHubè´¦å·æƒé™æ‰èƒ½æ›´æ–°

          roomGistId = SHARED_GIST_ID; // ä½¿ç”¨å›ºå®šID

          elements.roomStatusText.textContent = "â³ ç­‰å¾…å…¶ä»–äººåŠ å…¥...";

          // å¼€å§‹è½®è¯¢ç­‰å¾…answer
          pollForAnswerInSharedGist(roomId, offerTimestamp);
        } catch (error) {
          console.error("åˆ›å»ºç¬¬ä¸€ä¸ªç”¨æˆ·æˆ¿é—´å¤±è´¥:", error);
          throw error;
        }
      }

      // åŠ å…¥ç°æœ‰æˆ¿é—´
      async function joinExistingRoom(roomData) {
        try {
          if (!roomData || !roomData.offer) {
            throw new Error("æˆ¿é—´æ•°æ®æ— æ•ˆï¼Œæ²¡æœ‰æ‰¾åˆ°offer");
          }

          if (roomData.answer) {
            throw new Error("æˆ¿é—´å·²æ»¡ï¼Œå·²æœ‰å…¶ä»–ç”¨æˆ·è¿æ¥");
          }

          console.log("ğŸ”— è¿æ¥åˆ°æˆ¿é—´çš„offer");

          // åˆ›å»ºWebRTCè¿æ¥
          updateProgress(1, "active");
          pc = createConnection();

          // è®¾ç½®è¿œç¨‹offer
          await pc.setRemoteDescription(
            new RTCSessionDescription(roomData.offer)
          );

          updateProgress(2, "active");

          // åˆ›å»ºanswer
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);

          // ç­‰å¾…ICE gatheringå®Œæˆ
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          // æ›´æ–°æˆ¿é—´æ•°æ®ï¼Œæ·»åŠ answer
          roomData.answer = pc.localDescription;
          roomData.answerTimestamp = Date.now();

          // æ›´æ–°å…±äº«Gist
          const SHARED_GIST_ID = "55e80e797800fb3d2efd87782db79bb5";
          let sharedData = await readRoomGist(SHARED_GIST_ID);
          sharedData[currentRoomId] = roomData;

          const newGistId = await createRoomGist(
            `Shared Chat Rooms`,
            sharedData
          );
          console.log(`âœ… Answerå·²æ·»åŠ åˆ°å…±äº«Gist: ${newGistId}`);

          // æ›´æ–°Gist ID
          localStorage.setItem(`room_${currentRoomId}_gist_id`, newGistId);
          roomGistId = newGistId;

          updateProgress(3, "active");
          elements.roomStatusText.textContent = "ğŸ¤ æ­£åœ¨å»ºç«‹è¿æ¥...";
        } catch (error) {
          console.error("åŠ å…¥ç°æœ‰æˆ¿é—´å¤±è´¥:", error);
          throw error;
        }
      }

      // åœ¨å…±äº«Gistä¸­è½®è¯¢answer
      function pollForAnswerInSharedGist(roomId, offerTimestamp) {
        let pollCount = 0;
        const maxPolls = 100;

        const pollInterval = setInterval(async () => {
          try {
            pollCount++;
            elements.roomStatusText.textContent = `â³ ç­‰å¾…å…¶ä»–äººåŠ å…¥... (${Math.ceil(
              pollCount / 20
            )}åˆ†é’Ÿ)`;

            // è¯»å–æœ€æ–°çš„å…±äº«Gist ID
            const currentGistId = localStorage.getItem(
              `room_${roomId}_gist_id`
            );
            if (currentGistId) {
              const sharedData = await readRoomGist(currentGistId);

              if (
                sharedData &&
                sharedData[roomId] &&
                sharedData[roomId].answer
              ) {
                clearInterval(pollInterval);

                const answer = sharedData[roomId].answer;
                await pc.setRemoteDescription(
                  new RTCSessionDescription(answer)
                );

                updateProgress(3, "active");
                elements.roomStatusText.textContent = "ğŸ¤ æ­£åœ¨å»ºç«‹è¿æ¥...";
                return;
              }
            }

            if (pollCount >= maxPolls) {
              clearInterval(pollInterval);
              elements.roomStatusText.textContent = "â° ç­‰å¾…è¶…æ—¶ï¼Œè¯·é‡è¯•";
              elements.joinRoom.disabled = false;
            }
          } catch (error) {
            console.error("è½®è¯¢å…±äº«Gistå¤±è´¥:", error);
          }
        }, 3000);
      }

      // åŸºäºæˆ¿é—´å·ç”Ÿæˆå›ºå®šçš„Gist ID
      function generateRoomGistId(roomId) {
        // ä½¿ç”¨ä¸€ä¸ªå›ºå®šçš„ç®—æ³•å°†æˆ¿é—´å·è½¬æ¢ä¸º32ä½çš„hexå­—ç¬¦ä¸²
        // è¿™åªæ˜¯ç¤ºä¾‹ï¼Œå®é™…ä½¿ç”¨æ—¶æˆ‘ä»¬éœ€è¦ä¸€ä¸ªçœŸå®çš„å“ˆå¸Œç®—æ³•

        // ç®€å•çš„å­—ç¬¦ä¸²å“ˆå¸Œ
        let hash = 0;
        const str = roomId + "CHAT_ROOM_SALT_2025";
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
        }

        // è½¬æ¢ä¸ºæ­£æ•°å¹¶æ ¼å¼åŒ–ä¸º32ä½hexå­—ç¬¦ä¸²
        const positiveHash = Math.abs(hash);
        let hexId = positiveHash.toString(16).padStart(8, "0");

        // ç¡®ä¿æ˜¯32ä½hexæ ¼å¼ï¼ˆæ¨¡æ‹ŸGitHub Gist IDæ ¼å¼ï¼‰
        while (hexId.length < 32) {
          hexId = hexId + hexId;
        }
        hexId = hexId.substring(0, 32);

        return hexId;
      }

      // åˆ›å»ºæ–°æˆ¿é—´
      async function createNewRoom(roomId) {
        try {
          elements.roomStatusText.textContent = "ğŸ¯ åˆ›å»ºæˆ¿é—´å¹¶ç”Ÿæˆè¿æ¥ä¿¡æ¯...";

          // åˆ›å»ºWebRTCè¿æ¥
          updateProgress(1, "active");
          pc = createConnection();
          channel = pc.createDataChannel("chat");
          setupChannel();

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          // ç­‰å¾…ICE gatheringå®Œæˆ
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          const offerTimestamp = Date.now();
          const offerData = {
            type: "offer",
            offer: pc.localDescription,
            timestamp: offerTimestamp,
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          // åˆ›å»ºæˆ¿é—´æ•°æ®
          const roomData = {
            roomId: roomId,
            offers: [offerData],
            answers: [],
            created: Date.now(),
          };

          // ä¿å­˜æˆ¿é—´æ•°æ®
          const resourceId = await saveRoomData(roomId, roomData);
          roomGistId = `room_${roomId}`; // ä½¿ç”¨æ¨¡æ‹Ÿçš„ID

          console.log(`ğŸ¯ æˆ¿é—´ ${roomId} åˆ›å»ºæˆåŠŸ, èµ„æºID: ${resourceId}`);
          elements.roomStatusText.textContent = "â³ ç­‰å¾…å…¶ä»–äººåŠ å…¥...";

          // å¼€å§‹è½®è¯¢ç­‰å¾…answer
          pollForAnswer(offerTimestamp);
        } catch (error) {
          console.error("åˆ›å»ºæ–°æˆ¿é—´å¤±è´¥:", error);
          throw error;
        }
      }

      // åŠ å…¥æˆ¿é—´
      async function joinRoom(roomData) {
        try {
          if (!roomData || !roomData.offers) {
            throw new Error("æˆ¿é—´æ•°æ®æ— æ•ˆ");
          }

          console.log(
            `ğŸ“Š åˆ†ææˆ¿é—´æ•°æ®: offers=${roomData.offers.length}, answers=${
              roomData.answers ? roomData.answers.length : 0
            }`
          );

          // æŸ¥æ‰¾å¯ç”¨çš„offerï¼ˆæ²¡æœ‰å¯¹åº”answerçš„ï¼‰
          let availableOffer = null;

          for (const offer of roomData.offers) {
            const hasAnswer =
              roomData.answers &&
              roomData.answers.some(
                (answer) => answer.offerTimestamp === offer.timestamp
              );
            console.log(
              `ğŸ” æ£€æŸ¥Offer ${offer.timestamp}: ${
                hasAnswer ? "å·²æœ‰answer" : "å¯ç”¨"
              }`
            );
            if (!hasAnswer) {
              availableOffer = offer;
              break;
            }
          }

          if (availableOffer) {
            // æ‰¾åˆ°å¯ç”¨offerï¼Œä½œä¸ºanswererè¿æ¥
            console.log(
              `ğŸ”— æ‰¾åˆ°å¯ç”¨offerï¼Œä½œä¸ºanswererè¿æ¥: ${availableOffer.timestamp}`
            );
            elements.roomStatusText.textContent =
              "ğŸ”— æ‰¾åˆ°ç­‰å¾…ä¸­çš„ç”¨æˆ·ï¼Œæ­£åœ¨è¿æ¥...";
            await connectAsAnswerer(availableOffer);
          } else {
            // æ²¡æœ‰å¯ç”¨offerï¼Œä½œä¸ºæ–°çš„offerer
            console.log("ğŸ’« æ²¡æœ‰å¯ç”¨offerï¼Œä½œä¸ºæ–°çš„offerer");
            elements.roomStatusText.textContent = "ğŸ’« æ·»åŠ æ–°è¿æ¥...";
            await addOfferToRoom(roomData);
          }
        } catch (error) {
          console.error("åŠ å…¥æˆ¿é—´å¤±è´¥:", error);
          throw error;
        }
      }

      // ä½œä¸ºanswererè¿æ¥
      async function connectAsAnswerer(offer) {
        try {
          updateProgress(1, "active");

          // åˆ›å»ºWebRTCè¿æ¥
          pc = createConnection();

          // è®¾ç½®è¿œç¨‹offer
          await pc.setRemoteDescription(new RTCSessionDescription(offer.offer));

          updateProgress(2, "active");

          // åˆ›å»ºanswer
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);

          // ç­‰å¾…ICE gatheringå®Œæˆ
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          // å‡†å¤‡answeræ•°æ®
          const answerData = {
            type: "answer",
            answer: pc.localDescription,
            offerTimestamp: offer.timestamp,
            timestamp: Date.now(),
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          // æ›´æ–°æˆ¿é—´æ•°æ®ï¼šæ·»åŠ answer
          await addAnswerToRoom(answerData);

          updateProgress(3, "active");
          elements.roomStatusText.textContent = "ğŸ¤ æ­£åœ¨å»ºç«‹è¿æ¥...";
        } catch (error) {
          console.error("ä½œä¸ºanswererè¿æ¥å¤±è´¥:", error);
          throw error;
        }
      }

      // æ·»åŠ offeråˆ°æˆ¿é—´
      async function addOfferToRoom(roomData) {
        try {
          // åˆ›å»ºWebRTCè¿æ¥
          updateProgress(1, "active");
          pc = createConnection();
          channel = pc.createDataChannel("chat");
          setupChannel();

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          // ç­‰å¾…ICE gatheringå®Œæˆ
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          const offerTimestamp = Date.now();
          const offerData = {
            type: "offer",
            offer: pc.localDescription,
            timestamp: offerTimestamp,
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          // æ›´æ–°æˆ¿é—´æ•°æ®
          roomData.offers.push(offerData);

          // ä¿å­˜æ›´æ–°çš„æˆ¿é—´æ•°æ®
          await saveRoomData(currentRoomId, roomData);
          console.log(`âœ… Offerå·²æ·»åŠ åˆ°æˆ¿é—´ ${currentRoomId}`);
          elements.roomStatusText.textContent = "â³ ç­‰å¾…å…¶ä»–äººåŠ å…¥...";

          // å¼€å§‹è½®è¯¢ç­‰å¾…answer
          pollForAnswer(offerTimestamp);
        } catch (error) {
          console.error("æ·»åŠ offeråˆ°æˆ¿é—´å¤±è´¥:", error);
          throw error;
        }
      }

      // æ·»åŠ answeråˆ°æˆ¿é—´
      async function addAnswerToRoom(answerData) {
        try {
          // è¯»å–å½“å‰æˆ¿é—´æ•°æ®
          const roomData = await loadRoomData(currentRoomId);

          // æ·»åŠ answer
          if (!roomData.answers) roomData.answers = [];
          roomData.answers.push(answerData);

          // ä¿å­˜æ›´æ–°çš„æˆ¿é—´æ•°æ®
          await saveRoomData(currentRoomId, roomData);
          console.log(`âœ… Answerå·²æ·»åŠ åˆ°æˆ¿é—´ ${currentRoomId}`);
        } catch (error) {
          console.error("æ·»åŠ answeråˆ°æˆ¿é—´å¤±è´¥:", error);
          throw error;
        }
      }

      // ä½œä¸ºç¬¬ä¸€ä¸ªç”¨æˆ·åˆ›å»ºæˆ¿é—´
      async function createRoomAsFirstUser(roomId) {
        try {
          elements.roomStatusText.textContent = "ğŸ¯ ç”Ÿæˆè¿æ¥ä¿¡æ¯...";

          // åˆ›å»ºWebRTCè¿æ¥
          updateProgress(1, "active");
          pc = createConnection();
          channel = pc.createDataChannel("chat");
          setupChannel();

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          // ç­‰å¾…ICE gatheringå®Œæˆ
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          // è®°å½•offeræ—¶é—´æˆ³
          const offerTimestamp = Date.now();

          // åˆ›å»ºofferæ•°æ®
          const offerData = {
            type: "offer",
            offer: pc.localDescription,
            timestamp: offerTimestamp,
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          // ä¸Šä¼ offer
          await uploadOfferToRoom(offerData);
          elements.roomStatusText.textContent = "â³ ç­‰å¾…å…¶ä»–äººåŠ å…¥...";

          // å¼€å§‹è½®è¯¢ç­‰å¾…answer
          pollForAnswer(offerTimestamp);
        } catch (error) {
          console.error("åˆ›å»ºæˆ¿é—´å¤±è´¥:", error);
          throw error;
        }
      }

      // åŠ å…¥ç°æœ‰offers
      async function joinExistingOffers(offers) {
        try {
          elements.roomStatusText.textContent = "ğŸ” åˆ†æå¯ç”¨è¿æ¥...";

          // æ‰¾åˆ°æ²¡æœ‰answerçš„offer
          let availableOffer = null;

          for (const offer of offers) {
            const hasAnswer = await checkIfOfferHasAnswer(
              currentRoomId,
              offer.offerTimestamp
            );
            if (!hasAnswer) {
              availableOffer = offer;
              break;
            }
          }

          if (availableOffer) {
            // æ‰¾åˆ°å¯ç”¨çš„offerï¼Œè¿æ¥åˆ°å®ƒ
            elements.roomStatusText.textContent =
              "ğŸ”— æ‰¾åˆ°ç­‰å¾…ä¸­çš„ç”¨æˆ·ï¼Œæ­£åœ¨è¿æ¥...";
            await connectToFoundOffer(availableOffer);
          } else {
            // æ‰€æœ‰offeréƒ½æœ‰answeräº†ï¼Œä½œä¸ºæ–°ç”¨æˆ·åˆ›å»ºoffer
            elements.roomStatusText.textContent = "ğŸ’« åˆ›å»ºæ–°è¿æ¥...";
            await createRoomAsFirstUser(currentRoomId);
          }
        } catch (error) {
          console.error("åŠ å…¥ç°æœ‰offerså¤±è´¥:", error);
          throw error;
        }
      }

      // åˆ›å»ºæˆ¿é—´offer
      async function createRoomOffer() {
        try {
          updateProgress(1, "active");

          // åˆ›å»ºWebRTCè¿æ¥
          pc = createConnection();
          channel = pc.createDataChannel("chat");
          setupChannel();

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          // ç­‰å¾…ICE gatheringå®Œæˆ
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          // è®°å½•offeræ—¶é—´æˆ³
          const offerTimestamp = Date.now();

          // ä¸Šä¼ offeråˆ°æˆ¿é—´
          const offerData = {
            type: "offer",
            offer: pc.localDescription,
            timestamp: offerTimestamp,
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          await uploadOfferToRoom(offerData);
          elements.roomStatusText.textContent = "â³ ç­‰å¾…å…¶ä»–äººåŠ å…¥...";

          // å¼€å§‹è½®è¯¢ç­‰å¾…answerï¼ˆä¼ å…¥offeræ—¶é—´æˆ³ï¼‰
          pollForAnswer(offerTimestamp);
        } catch (error) {
          console.error("åˆ›å»ºofferå¤±è´¥:", error);
          throw error;
        }
      }

      // æ™ºèƒ½åŠ å…¥æˆ¿é—´ï¼ˆæ··åˆç­–ç•¥ï¼‰
      async function smartJoinRoom(roomData) {
        try {
          elements.roomStatusText.textContent = "ğŸ” åˆ†ææˆ¿é—´çŠ¶æ€...";

          // ç­–ç•¥1ï¼šé¦–å…ˆæ£€æŸ¥æˆ¿é—´ä¸»Gistä¸­çš„offersï¼ˆæ›´å¯é ï¼‰
          let availableOffers = [];
          if (roomData && roomData.offers && roomData.offers.length > 0) {
            // æ£€æŸ¥æˆ¿é—´ä¸­çš„offersæ˜¯å¦æœ‰å¯ç”¨çš„
            for (const offer of roomData.offers) {
              const hasAnswer =
                roomData.answers &&
                roomData.answers.some(
                  (answer) => answer.offerTimestamp === offer.timestamp
                );
              if (!hasAnswer) {
                availableOffers.push({
                  gistId: null, // æ¥è‡ªä¸»æˆ¿é—´
                  offerTimestamp: offer.timestamp,
                  offer: offer,
                });
              }
            }
          }

          // ç­–ç•¥2ï¼šå¦‚æœä¸»Gistä¸­æ²¡æœ‰å¯ç”¨offersï¼Œå°è¯•æœç´¢ç‹¬ç«‹çš„offer gists
          if (availableOffers.length === 0) {
            elements.roomStatusText.textContent = "ğŸ” æœç´¢ç‹¬ç«‹è¿æ¥...";
            const searchOffers = await searchRoomOffers(currentRoomId);

            for (const offer of searchOffers) {
              const hasAnswer = await checkIfOfferHasAnswer(
                currentRoomId,
                offer.offerTimestamp
              );
              if (!hasAnswer) {
                availableOffers.push(offer);
              }
            }
          }

          if (availableOffers.length === 0) {
            // æ²¡æœ‰æ‰¾åˆ°ä»»ä½•å¯ç”¨offerï¼Œä½œä¸ºæ–°ç”¨æˆ·åˆ›å»º
            elements.roomStatusText.textContent = "ğŸ¯ åˆ›å»ºæ–°è¿æ¥...";
            await createRoomOffer();
            return;
          }

          // æ‰¾åˆ°å¯ç”¨çš„offerï¼Œè¿æ¥åˆ°æœ€æ–°çš„ä¸€ä¸ª
          const latestOffer = availableOffers[0]; // å·²ç»æŒ‰æ—¶é—´æ’åº
          elements.roomStatusText.textContent =
            "ğŸ”— æ‰¾åˆ°ç­‰å¾…ä¸­çš„ç”¨æˆ·ï¼Œæ­£åœ¨è¿æ¥...";
          await connectToFoundOffer(latestOffer);
        } catch (error) {
          console.error("æ™ºèƒ½åŠ å…¥æˆ¿é—´å¤±è´¥:", error);
          // é™çº§ï¼šç›´æ¥åˆ›å»ºæ–°çš„offer
          elements.roomStatusText.textContent = "ğŸ”„ å°è¯•åˆ›å»ºæ–°è¿æ¥...";
          await createRoomOffer();
        }
      }

      // æ£€æŸ¥offeræ˜¯å¦å·²æœ‰answerï¼ˆç®€åŒ–ç‰ˆï¼‰
      async function checkIfOfferHasAnswer(roomId, offerTimestamp) {
        try {
          const answerGist = await searchAnswerGist(roomId);
          if (answerGist) {
            // è¯»å–answeræ•°æ®æ£€æŸ¥æ—¶é—´æˆ³åŒ¹é…
            const answerData = await readRoomGist(answerGist.id);
            return answerData && answerData.offerTimestamp === offerTimestamp;
          }
          return false;
        } catch (error) {
          console.error("æ£€æŸ¥answerå¤±è´¥:", error);
          return false;
        }
      }

      // è¿æ¥åˆ°æ‰¾åˆ°çš„offer
      async function connectToFoundOffer(offerInfo) {
        try {
          updateProgress(1, "active");

          // åˆ›å»ºWebRTCè¿æ¥
          pc = createConnection();

          // è®¾ç½®è¿œç¨‹offer
          await pc.setRemoteDescription(
            new RTCSessionDescription(offerInfo.offer.offer)
          );

          updateProgress(2, "active");

          // åˆ›å»ºanswer
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);

          // ç­‰å¾…ICE gatheringå®Œæˆ
          await new Promise((resolve) => {
            pc.onicecandidate = (e) => {
              if (!e.candidate) {
                resolve();
              }
            };
          });

          // ä¸Šä¼ answeråˆ°æˆ¿é—´
          const answerData = {
            type: "answer",
            answer: pc.localDescription,
            offerTimestamp: offerInfo.offerTimestamp,
            timestamp: Date.now(),
            userId: "user_" + Math.random().toString(36).substr(2, 9),
          };

          await uploadAnswerToRoom(answerData);

          updateProgress(3, "active");
          elements.roomStatusText.textContent = "ğŸ¤ æ­£åœ¨å»ºç«‹è¿æ¥...";
        } catch (error) {
          console.error("è¿æ¥åˆ°æ‰¾åˆ°çš„offerå¤±è´¥:", error);
          throw error;
        }
      }

      // ä¸Šä¼ offeråˆ°æˆ¿é—´ï¼ˆä¿®å¤ç‰ˆæœ¬ï¼‰
      async function uploadOfferToRoom(offerData) {
        try {
          // ä½¿ç”¨offerçš„æ—¶é—´æˆ³ç¡®ä¿ä¸€è‡´æ€§
          const offerTimestamp = offerData.timestamp;
          const offerGistData = {
            roomId: currentRoomId,
            type: "room_offer",
            offer: offerData,
            timestamp: offerTimestamp,
          };

          const offerGistId = await createGist(
            `Chat Room: ${currentRoomId} - Offer ${offerTimestamp}`,
            `offer_${currentRoomId}_${offerTimestamp}.json`,
            offerGistData
          );

          // ä¿å­˜offerçš„Gist IDï¼Œç”¨äºåç»­æ£€æŸ¥
          const offerCache = JSON.parse(
            localStorage.getItem("offerCache") || "{}"
          );
          if (!offerCache[currentRoomId]) {
            offerCache[currentRoomId] = [];
          }
          offerCache[currentRoomId].push({
            gistId: offerGistId,
            timestamp: offerTimestamp,
            offerTimestamp: offerTimestamp,
          });
          localStorage.setItem("offerCache", JSON.stringify(offerCache));

          console.log(`Offer uploaded to Gist: ${offerGistId}`);

          // åŒæ—¶ä¿å­˜åˆ°æˆ¿é—´çš„ä¸»Gistä¸­ï¼ˆä½œä¸ºå¤‡ä»½ï¼‰
          await updateRoomWithOffer(offerData);
        } catch (error) {
          console.error("ä¸Šä¼ offerå¤±è´¥:", error);
          throw error;
        }
      }

      // æ›´æ–°æˆ¿é—´ä¸»Gistï¼ˆæ·»åŠ offerä½œä¸ºå¤‡ä»½ï¼‰
      async function updateRoomWithOffer(offerData) {
        try {
          if (!roomGistId) return;

          // è¯»å–å½“å‰æˆ¿é—´æ•°æ®
          const roomData = await readGist(roomGistId);
          if (roomData) {
            // æ·»åŠ offeråˆ°æˆ¿é—´æ•°æ®ä¸­
            if (!roomData.offers) roomData.offers = [];
            roomData.offers.push(offerData);

            // åˆ›å»ºæ–°çš„æˆ¿é—´Gist
            const newRoomGistId = await createGist(
              `Chat Room: ${currentRoomId} - Updated`,
              `room_${currentRoomId}.json`,
              roomData
            );

            // æ›´æ–°ç¼“å­˜
            saveRoomGistId(currentRoomId, newRoomGistId);
            roomGistId = newRoomGistId;
          }
        } catch (error) {
          console.warn("æ›´æ–°æˆ¿é—´ä¸»Gistå¤±è´¥:", error);
          // ä¸æŠ›å‡ºé”™è¯¯ï¼Œå› ä¸ºè¿™åªæ˜¯å¤‡ä»½
        }
      }

      // ä¸Šä¼ answeråˆ°æˆ¿é—´ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼‰
      async function uploadAnswerToRoom(answerData) {
        try {
          // åˆ›å»ºåŒ…å«answerçš„ç‹¬ç«‹Gist
          const timestamp = Date.now();
          const answerGistData = {
            roomId: currentRoomId,
            type: "room_answer",
            answer: answerData,
            timestamp: timestamp,
          };

          const answerGistId = await createGist(
            `Chat Room: ${currentRoomId} - Answer ${timestamp}`,
            `answer_${currentRoomId}_${answerData.offerTimestamp}.json`,
            answerGistData
          );

          console.log(`Answer uploaded to Gist: ${answerGistId}`);

          // åŒæ—¶ä¿å­˜åˆ°æˆ¿é—´çš„ä¸»Gistä¸­ï¼ˆä½œä¸ºå¤‡ä»½ï¼‰
          await updateRoomWithAnswer(answerData);
        } catch (error) {
          console.error("ä¸Šä¼ answerå¤±è´¥:", error);
          throw error;
        }
      }

      // æ›´æ–°æˆ¿é—´ä¸»Gistï¼ˆæ·»åŠ answerä½œä¸ºå¤‡ä»½ï¼‰
      async function updateRoomWithAnswer(answerData) {
        try {
          if (!roomGistId) return;

          // è¯»å–å½“å‰æˆ¿é—´æ•°æ®
          const roomData = await readGist(roomGistId);
          if (roomData) {
            // æ·»åŠ answeråˆ°æˆ¿é—´æ•°æ®ä¸­
            if (!roomData.answers) roomData.answers = [];
            roomData.answers.push(answerData);

            // åˆ›å»ºæ–°çš„æˆ¿é—´Gist
            const newRoomGistId = await createGist(
              `Chat Room: ${currentRoomId} - Complete`,
              `room_${currentRoomId}.json`,
              roomData
            );

            // æ›´æ–°ç¼“å­˜
            saveRoomGistId(currentRoomId, newRoomGistId);
            roomGistId = newRoomGistId;
          }
        } catch (error) {
          console.warn("æ›´æ–°æˆ¿é—´ä¸»Gistå¤±è´¥:", error);
          // ä¸æŠ›å‡ºé”™è¯¯ï¼Œå› ä¸ºè¿™åªæ˜¯å¤‡ä»½
        }
      }

      // è½®è¯¢ç­‰å¾…answerï¼ˆçº¯Gistæ–¹æ¡ˆï¼‰
      function pollForAnswer(roomId, myOfferTimestamp) {
        let pollCount = 0;
        const maxPolls = 100; // æœ€å¤šè½®è¯¢100æ¬¡ (5åˆ†é’Ÿ)

        const pollInterval = setInterval(async () => {
          try {
            pollCount++;
            elements.roomStatusText.textContent = `â³ ç­‰å¾…answer... (${Math.ceil(
              pollCount / 20
            )}åˆ†é’Ÿ)`;

            // æœç´¢answer Gist
            const answerGist = await searchAnswerGist(roomId);

            if (answerGist) {
              clearInterval(pollInterval);

              // è¯»å–answeræ•°æ®
              const answerData = await readRoomGist(answerGist.id);
              console.log("æ‰¾åˆ°answeræ•°æ®:", answerData);

              if (
                answerData &&
                answerData.offerTimestamp === myOfferTimestamp
              ) {
                // è®¾ç½®è¿œç¨‹answer
                await pc.setRemoteDescription(
                  new RTCSessionDescription(answerData.answer)
                );

                updateProgress(3, "active");
                elements.roomStatusText.textContent = "ğŸ¤ æ­£åœ¨å»ºç«‹è¿æ¥...";
                return;
              }
            }

            if (pollCount >= maxPolls) {
              clearInterval(pollInterval);
              elements.roomStatusText.textContent = "â° ç­‰å¾…è¶…æ—¶ï¼Œè¯·é‡è¯•";
              elements.joinRoom.disabled = false;
            }
          } catch (error) {
            console.error("è½®è¯¢answerå¤±è´¥:", error);
            // ç»§ç»­è½®è¯¢ï¼Œä¸ä¸­æ–­
          }
        }, 3000); // æ¯3ç§’è½®è¯¢ä¸€æ¬¡
      }

      // äº‹ä»¶ç»‘å®š

      // Tokenä¿å­˜äº‹ä»¶
      elements.saveToken.onclick = () => {
        const token = elements.githubTokenRequired.value.trim();
        if (token && token.length > 10) {
          localStorage.setItem("githubToken", token);
          showToast("Tokenå·²ä¿å­˜ï¼");
          showMainInterface();
        } else {
          showToast("è¯·è¾“å…¥æœ‰æ•ˆçš„GitHub Token", "error");
        }
      };

      // Tokenè¾“å…¥æ¡†å›è½¦äº‹ä»¶
      elements.githubTokenRequired.onkeypress = (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          elements.saveToken.click();
        }
      };

      // åˆ›å»ºæˆ¿é—´æŒ‰é’®äº‹ä»¶
      elements.createRoomBtn.onclick = async () => {
        const newRoomId = generateRoomId();
        showToast(`æˆ¿é—´å·å·²ç”Ÿæˆ: ${newRoomId}`);

        // è‡ªåŠ¨å¤åˆ¶æˆ¿é—´å·
        try {
          await navigator.clipboard.writeText(newRoomId);
          showToast(`æˆ¿é—´å· ${newRoomId} å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼`);
        } catch (error) {
          console.warn("è‡ªåŠ¨å¤åˆ¶å¤±è´¥:", error);
        }

        // è‡ªåŠ¨è¿æ¥åˆ°æˆ¿é—´
        currentRoomId = newRoomId;
        elements.roomStatus.style.display = "block";
        elements.roomStatusText.textContent = "ğŸ¯ åˆ›å»ºæˆ¿é—´ä¸­...";

        await createOfferAndWait(newRoomId);
      };

      // åŠ å…¥æˆ¿é—´æŒ‰é’®äº‹ä»¶
      elements.joinRoomBtn.onclick = () => {
        elements.joinRoomSection.style.display = "block";
        setTimeout(() => {
          elements.roomIdInput.focus();
        }, 100);
      };

      // åŠ å…¥æˆ¿é—´ç¡®è®¤äº‹ä»¶
      elements.joinRoom.onclick = async () => {
        const roomId = elements.roomIdInput.value.trim();
        await connectToRoom(roomId);
      };

      // æˆ¿é—´å·è¾“å…¥æ¡†å›è½¦äº‹ä»¶
      elements.roomIdInput.onkeypress = (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          elements.joinRoom.click();
        }
      };

      // æˆ¿é—´å·è¾“å…¥æ¡†è‡ªåŠ¨æ ¼å¼åŒ–
      elements.roomIdInput.oninput = (e) => {
        let value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, "");
        if (value.length > 6) value = value.substring(0, 6);
        e.target.value = value;
      };

      elements.send.onclick = sendMessage;
      elements.messageInput.onkeypress = (e) => {
        if (e.key === "Enter") sendMessage();
      };

      // å›¾ç‰‡ç›¸å…³äº‹ä»¶ç»‘å®š
      elements.imageBtn.onclick = () => {
        elements.fileInput.click();
      };

      elements.fileInput.onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
          handleImageFile(file);
        }
      };

      elements.cancelImage.onclick = hideImagePreview;

      // ç»‘å®šç²˜è´´äº‹ä»¶
      elements.messageInput.addEventListener("paste", handlePaste);
      document.addEventListener("paste", (e) => {
        // åªæœ‰å½“è¾“å…¥æ¡†è·å¾—ç„¦ç‚¹æˆ–è€…æ²¡æœ‰å…¶ä»–è¾“å…¥æ¡†æ—¶æ‰å¤„ç†ç²˜è´´
        if (
          document.activeElement === elements.messageInput ||
          !document.activeElement ||
          document.activeElement === document.body
        ) {
          handlePaste(e);
        }
      });

      // é”®ç›˜å¿«æ·é”®æ”¯æŒï¼ˆç®€åŒ–ç‰ˆï¼‰
      document.addEventListener("keydown", (e) => {
        // åœ¨æˆ¿é—´å·è¾“å…¥æ¡†ä¸­æŒ‰å›è½¦è‡ªåŠ¨è¿æ¥
        if (
          e.key === "Enter" &&
          document.activeElement === elements.roomIdInput
        ) {
          e.preventDefault();
          elements.joinRoom.click();
        }
      });

      // è°ƒè¯•å‡½æ•°ï¼šæ˜¾ç¤ºæˆ¿é—´çŠ¶æ€
      window.debugRoom = async function (roomId) {
        console.log(`=== æˆ¿é—´ ${roomId} è°ƒè¯•ä¿¡æ¯ ===`);

        try {
          // æœç´¢æˆ¿é—´Gist
          const roomGist = await findRoomGist(roomId);
          if (roomGist) {
            console.log("æ‰¾åˆ°æˆ¿é—´Gist ID:", roomGist.id);
            const roomData = await readGist(roomGist.id);
            console.log("æˆ¿é—´æ•°æ®:", roomData);

            if (roomData.offers) {
              console.log(`æˆ¿é—´å†…æœ‰ ${roomData.offers.length} ä¸ªoffers:`);
              roomData.offers.forEach((offer, index) => {
                const hasAnswer =
                  roomData.answers &&
                  roomData.answers.some(
                    (answer) => answer.offerTimestamp === offer.timestamp
                  );
                console.log(
                  `  Offer ${index + 1} (${offer.timestamp}): ${
                    hasAnswer ? "å·²æœ‰answer" : "ç­‰å¾…answer"
                  }`
                );
              });
            }

            if (roomData.answers) {
              console.log(`æˆ¿é—´å†…æœ‰ ${roomData.answers.length} ä¸ªanswers`);
            }
          } else {
            console.log("æ²¡æœ‰æ‰¾åˆ°æˆ¿é—´ï¼Œæˆ¿é—´ä¸å­˜åœ¨æˆ–æœç´¢å¤±è´¥");
          }

          // æ˜¾ç¤ºå½“å‰è¿æ¥çŠ¶æ€
          console.log("å½“å‰æˆ¿é—´ID:", currentRoomId);
          console.log("å½“å‰æˆ¿é—´Gist ID:", roomGistId);
          console.log("WebRTCè¿æ¥çŠ¶æ€:", pc ? pc.connectionState : "æœªåˆ›å»º");
        } catch (error) {
          console.error("è°ƒè¯•å¤±è´¥:", error);
        }
      };

      // æ¸…é™¤ç¼“å­˜çš„è°ƒè¯•å‡½æ•°
      window.clearRoomCache = function () {
        localStorage.clear();
        console.log("å·²æ¸…é™¤æ‰€æœ‰ç¼“å­˜");
      };

      // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
      document.addEventListener("DOMContentLoaded", () => {
        initializeToken();

        // å¼€å‘æ¨¡å¼æç¤º
        console.log("ğŸ”§ è°ƒè¯•æç¤º:");
        console.log("  debugRoom('æˆ¿é—´å·') - æŸ¥çœ‹æˆ¿é—´çŠ¶æ€");
        console.log("  clearRoomCache() - æ¸…é™¤æ‰€æœ‰ç¼“å­˜");
      });
    </script>
  </body>
</html>
